\documentclass[12pt]{article}
\usepackage{ltcadiz}
\usepackage{listings, a4wide}
\lstset{breaklines=true, numbers=left}

\title{Report on OGO 2.2 Softwarespecification\\ Assignment 1a}
\author{
        Femke Jansen and Lasse Blaauwbroek OGO 2.2 group 6 \\
                Department of Computer Science\\
        Technical University Eindhoven\\
}
\date{\today}

\begin{document}

\maketitle

\subsubsection{Basic Axiomatic definitions}
We define several attributes that we will use in later definitions in our Z schemas. Since some returned objects in our class diagram may contain null values, we have defined it as a separate set. \\
In our class diagram, we use several enumerators: Hint, BoardResponse and Rotation. Below, we have given the Z specification of these enumerators.

\begin{axdef}
Rotation == \{0, 90, 180, 270\}
\end{axdef}

\begin{axdef}
BoardResponse == \{FAILED, SUCCESS, WIN\}
\end{axdef}

\begin{axdef}
Hint == \{NORTH, EAST, SOUTH, WEST, NORTH\_EAST, \\ \t1 SOUTH\_EAST, SOUTH\_WEST, NORTH\_WEST\}
\end{axdef}

\begin{zed}
[Null]
\end{zed}

\subsubsection{Classes}
We distinguish between two types of coordinates: absolute coordinates and relative coordinates. The absolute coordinates describe the coordinates of individual tiles on the Board; these coordinates have an x- and y-value, which are both natural numbers. The relative coordinates are used by Robots to make a move request; the relative coordinates also have an x- and y-value, but these numbers are integers. Since the move requests are communicated to the Board, the Board itself will determine the absolute coordinates that belong to these relative coordinates.

\begin{class}{Coord}
\upharpoonright (x, y) \\
\begin{state}
x : \num \\
y : \num
\end{state} \\
\begin{schema}{add}
\Delta (x, y) \\
coord? : Coord
\where
x' = coord?.x + x \\
y' = coord?.y + y
\end{schema}
\end{class}

\begin{class}{AbsoluteCoord}
Coord \\
\begin{axdef}
BoardWith, BoardHeight : \nat
\end{axdef} \\
\begin{state}
\where
0 \leq x < BoardWidth \\
0 \leq y < BoardHeight
\end{state}
\end{class}

\begin{class}{RelativeCoord}
Coord \\
\end{class}

Tile class has five specializations: NormalTile, HomeTile, HintTile, ConveyerTile and BrokenRobotTile. A Tile has a type, which is either of the above specializations, and a field 'occupier', which describes the robot that currently occupies the tile. Note that a tile does not necessarily have to be occupied by a robot, so occupies can also be null. All the specializations of Tile inherit the characteristics of Tile.
\begin{class}{Tile}
\upharpoonright (occupier) \\
\begin{state}
occupier : Robot \cup Null \\
isSnapshotTile : \bool \\
\end{state} \\
\begin{schema}{Init}
occupier = Null
\end{schema} \\
\begin{classcom}
clearTile is a help-method that clears the occupies variable of a Tile.
\end{classcom} \\
\begin{schema}{clear}
\Delta (occupier) \\
\where
occupier' = Null
\end{schema} \\
\begin{classcom}
put is a help-method that takes a robot as input-variable and sets the occupies-variable of a Tile to this robot.
\end{classcom}\\
\begin{schema}{put}
\Delta (occupier) \\
input? : Robot
\where
occupier' = input?
\end{schema} \\
\begin{schema}{rotate}
\Delta()
\end{schema}
\end{class}

\begin{class}{NormalTile}
Tile
\end{class}

\begin{class}{HintTile}
Tile
\end{class}

\begin{class}{BrokenRobotTile}
Tile
\end{class}

\begin{class}{HomeTile}
Tile \\
\upharpoonright (target) \\
\begin{classcom}
A HomeTile always belongs to one specific Robot, the target robot.
\end{classcom} \\
\begin{state}
target : Robot
\end{state}
\end{class}

\begin{class}{ConveyorTile}
Tile \\
\upharpoonright (rotation) \\
\begin{classcom}
A ConveyerTile has a certain rotation, which influences the direction in which a robot is transported.
\end{classcom} \\
\begin{state}
rotation : Rotation
\end{state} \\
\begin{classcom}
Left empty on purpose.
\end{classcom} \\
\begin{schema}{rotate}
\Delta (rotation)
\end{schema}
\end{class}

The Board class maintains several invariants and has a variety of methods, since it is one of the major components of the game.

\begin{class}{Board}
\upharpoonright (canReset, initialize) \\
\begin{state}
tiles : \power (AbsoluteCoord \fun \: \downarrow \! Tile) \\
robots : \power (Robot \fun Rotation) \\
\also \also \also
controller : Controller \\
occupied : \power AbsoluteCoord \\
adjacent : \power (AbsoluteCoord \rel AbsoluteCoord) \\
conveyorDest : \power (AbsoluteCoord \pinj AbsoluteCoord) \\
\where
\forall t : \ran tiles | \neg t.isSnaphotTile
\also \also \also \also
\forall c : occupied | tiles(c) \in BrokenRobotTile \vee
tiles(c).occupier \not = Null \\
\also \also \also \also
\forall (c, d) : conveyorUnitDest | d \not \in occupied \; \wedge tiles(c) \in ConveyorTile \; \; \wedge \\ \t1
        tiles(c).rotation = 0 \Rightarrow (c.x = d.x + 1 \wedge c.y = d.y) \; \; \wedge \\ \t1
        tiles(c).rotation = 90 \Rightarrow (c.x = d.x \wedge c.y = d.y - 1) \; \; \wedge \\ \t1
        tiles(c).rotation = 180 \Rightarrow (c.x = d.x - 1 \wedge c.y = d.y) \; \; \wedge \\ \t1
        tiles(c).rotation = 270 \Rightarrow (c.x = d.x \wedge c.y = d.y + 1) \; \; \\
\also \also \also \also
\forall (c, d) : adjacent | ~ |\!c.x - d.x\!| + |\!c.y - d.y\!| = 1 \wedge d \not \in occupied
\also \also \also \also
\forall r : robots | \exists c, d : \dom tiles @  \\ \t1 tiles(c) \in HomeTile \wedge tiles(c).target = r \; \; \wedge \\ \t1
d.occupier = r \wedge (c, d) \in (adjacent \cup conveyorDest)\star
\end{state} \\
\begin{classcom}
Initialize is called from the outside world, when a new game has to be started. Note that the tiles and robots in this method are read from an input file. After the tiles and robots have been initiated, the Board pre-initializes the Controller and initializes all the robots. Finally, the Board post-initializes the Controller with the initialized Robots and the Board.
\end{classcom} \\
\begin{schema}{Init}
reset
\end{schema} \\
\begin{schema}{internalInit}
\Delta (tiles, robots, controller)
\where
tiles' \not = Null \\
robots' \not = Null \\
controller' \not = Null
\end{schema} \\
initialize \sdef internalInit \comp controller.preInitialize \; \comp \\ \t1 
[c : Controller | c = controller] @ \bigwedge_{r : dom Robots} robots.initialize \; \comp \\ \t1
[r : \power Robots | r = \dom Robots] @ controller.postInitialize \\
\znewpage
\begin{classcom}
CanReset is used by the Controller to let the Board know that the game has ended and that the Board can reset. The Board can reset whenever there is HomeTile on the Board that is occupied by the target robot.
\end{classcom} \\
\begin{classcom}
Uitleg waarom init leeg is.
\end{classcom} \\
canReset \sdef [\exists t : \ran tiles | t \in HomeTileTiles @ \\
\t1 t.target = t.occupier] \wedge reset \\
\begin{classcom}
When the Board resets itself, the tiles, the controller and the robots are deleted.
\end{classcom} \\
\begin{schema}{reset}
\Delta (tiles, robots)
\where
tiles' = Null \\
robots' = Null \\
controller' = Null
\end{schema} \\
\begin{classcom}
We make a snapshot by copying all the tiles and adding a mapping (same as for the original board). Next, with this snapshot the view can display the board.
\end{classcom} \\
\begin{schema}{requestSnapShot}
snapshot? : BoardSnapshot
\where
\forall (c1,t1) : tiles | \exists (c2,t2) : snapshot? | c1 = c2 \: \wedge \\ \t2
t1.occupier = t2.occupier \: \wedge \\ \t2 
t1 \in NormalTile \Rightarrow t2 \in NormalTile \: \wedge \\ \t2
t1 \in HintTile \Rightarrow t2 \in HintTile \: \wedge \\ \t2
t1 \in BrokenRobotTile \Rightarrow t2 \in BrokenRobotTile \: \wedge \\ \t2
t1 \in HomeTile \Rightarrow (t2 \in HomeTile \wedge t1.target = t2.target) \: \wedge \\ \t2 
t1 \in ConveyorTile \Rightarrow \\ \t3 (t2 \in ConveyorTile \wedge t2.rotation = t2.rotation)
\end{schema} \\
\znewpage
\begin{classcom}
GetHint is used by the Board to generate a hint. It takes the robot that requested a move as input-parameter. It checks where the HomeTile of the robot is and according to that gives the appropiate hint.
\end{classcom} \\
\begin{axdef}
hintMapping : \power ((\{-1, 0, 1\} \cross \{-1, 0, 1\}) \pfun \power Hint)
\where
hintMapping(-1, -1) = \{NORTH\_WEST, NORTH, WEST\} \\
hintMapping(-1, 0) = \{WEST\} \\
hintMapping(-1, 1) = \{SOUTH\_WEST, SOUTH, WEST\} \\
hintMapping(0, -1) = \{NORTH\} \\
hintMapping(0, 1) = \{SOUTH\} \\
hintMapping(1, -1) = \{NORTH\_EAST, NORTH, EAST\} \\
hintMapping(1, 0) = \{EAST\} \\
hintMapping(1, 1) = \{SOUTH\_EAST, SOUTH, EAST\} \\
\end{axdef} \\
\begin{axdef}
rotate90Deg : \power (Hint \fun Hint)
\where
rotate90Deg(NORTH) = WEST \\
rotate90Deg(WEST) = SOUTH \\
rotate90Deg(SOUTH) = EAST \\
rotate90Deg(EAST) = NORTH \\
rotate90Deg(NORTH\_EAST) = NORTH\_WEST \\
rotate90Deg(NORTH\_WEST) = SOUTH\_WEST \\
rotate90Deg(SOUTH\_WEST) = SOUTH\_EAST \\
rotate90Deg(SOUTH\_EAST) = NORTH\_EAST
\end{axdef} \\
\begin{schema}{getHint}
robot? : Robot \\
output!: Hint \\
\delta x : \{-1, 0, 1\} \\
\delta y : \{-1, 0, 1\} \\
numRotations : \nat
\where
numRotations = \frac{robots(robot?)}{90} \\
\also \also \also \also \also
\exists c1,c2 : \ran tiles, h : Hint | \\ \t1 c1 \in HomeTile \wedge
 tiles(c1).target = robot? \; \; \wedge \\ \t1 tiles(c2).occupier = robot? \wedge
 \delta x = \frac{c1.x - c2.x}{|c1.x - c2.x|} \wedge \delta y = \frac{c1.y - c2.y}{|c1.y - c2.y|} \; \; \wedge \\ \t1
 h \in robot.hintMapping(\delta x, \delta y) \; \; \wedge \\ \t1
 output! = rotate90Deg^{numRatations}(h)
\end{schema} \\
\znewpage
\begin{classcom}
getValidTiles corresponds to the private method in Board. The output is a pair of two valid tiles. A tile is valid for an exchange if it is not a HomeTile or a HintTile. Off course, the invariant also holds for this function.
\end{classcom} \\
\begin{schema}{getValidTiles}
tilePair! : Tile \cross Tile
\where
\exists b : Board, (c1, t1), (c2, t2) : tiles | \\ \t1
b.robots = robots \;\; \wedge \\ \t1
 b.tiles = (tiles \setminus \{(c1, t1), (c2, t2)\}) \cup \{(c1, t2), (c2, t1)\} \\ \t1
t1 \not = t2 \; \;  \wedge \\ \t1
t1 \not \in HomeTile \wedge t1 \not \in HintTile \; \; \wedge \\ \t1
t2 \not \in HomeTile \wedge t2 \not \in HintTile \; \; \wedge \\ \t1
tilePair! = (t1, t2)
\end{schema} \\
\begin{classcom}
Method to exchange the positions of two tiles on the board. These tiles should be valid. If a robot is on one of the tiles, it moves along.
\end{classcom} \\
\begin{schema}{exchangeTiles}
\Delta(tiles, robots) \\
tilePair? : Tile \cross Tile \\
exchangedPair! : Tile \cross Tile \\
robotPair! : (Robot \cup Null) \cross (Robot \cup Null)
\where
tilePair? = exchangedPair! \\
\also \also \also
\exists c1, c2 : \dom tiles | tiles(c1) = tilePair?.0 \wedge tiles(c2) = tilePair?.1 \; \; \wedge \\ \t1
tiles' = tiles \setminus \{(c1, tilePair?.0),(c2, tilePair?.1)\} \cup \\ \t2 \{(c1, tilePair?.1),(c2, tilePair?.0)\}
\\ \t1 \forall r : \dom robots | \\ \t2 (r \not = tiles(c1).occupier \wedge r \not = tiles(c2).occupier) \Rightarrow \\ \t3 robots'(r) = robots(r) \\ \t1
robotPair! = (tiles(c1).occupier, tiles(c2).occupier)
\end{schema} \\
requestTilesExchange \sdef getValidTiles \comp exchangeTiles \; \; \comp \\
\t1 [t1, t2 : Tile | t1 = exchangedPair?.0 \wedge t2 = exchangedPair?.1] @ \\ \t2 t1.rotate \wedge t2.rotate \\ \t1
\znewpage
\begin{classcom}
This functions deals with the moveRequest of the controller
\end{classcom} \\
\begin{schema}{moveRequest}
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
absoluteCoord : AbsoluteCoord \\
output! : BoardResponse
\where
\IF rotation? \not = 0 \\
\THEN response! = moveRotate(localCoords?, robot?, rotation?) \\
\ELSE response! = moveWalk(localCoords?, robot?)
\end{schema} \\
\begin{classcom}
Used to deal with rotations a robot wants to make.
\end{classcom} \\
\begin{schema}{moveRotate}
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
output! : BoardResponse
\where
\IF localCoords.x = 0 \\ \t1
localCoords.y = 0 \\ \t1
 \exists r : robot?.rule.possibleRotations | r = rotation?\\
\THEN output! = SUCCESS \\ \t1
robots(robot?) = (robots(robot?) + rotation?) \mod 360 \\
\ELSE output! = FAILED
\end{schema} \\
\begin{classcom}
Used to deal with other movements a robot wants to make.
\end{classcom} \\
\begin{schema}{moveWalk}
localCoords? : RelativeCoord \\
robot? : Robot \\
output! : BoardResponse
\where
\IF robot?.rule.possibleMoves(localCoords?, robots(robot?)) = \\ \t1
possiblePath(robot?) \wedge rotation? = 0 \\
\THEN absoluteCoord = calculateNewLocation(localCoords?, robot?)\\ \t1
\IF absoluteCoord = Null \\ \t1
\THEN output! = FAILED \\ \t1
\ELSE output! = checkTile(absoluteCoord?, robot?)\\ \t2
\ELSE output! = FAILED
\end{schema} \\
\znewpage
\begin{classcom}
Subfunction of moveWalk, used to check on which tile the robot will end and gives the proper response.
\end{classcom} \\
\begin{schema}{checkTile}
absoluteCoord? : AbsoluteCoord \\
robot? : Robot \\
output! : BoardResponse
\where
saveLocation(absoluteCoord?, robot?) \\
\IF tiles(absoluteCoord?).type = HomeTile \\ \t1
tiles(absoluteCoord?).target = robot? \\
\THEN output! = WIN \\ \
\ELSE  \\ \t1
\IF tiles(absoluteCoord?).type = ConveyorTile \\ \t1
\THEN controller.notifyAutomovement(robot?) \\ \t1
\IF tiles(absoluteCoord?).type = HintTile \\ \t1
\THEN controller.notifyHint(Board.getHint(robot?), robot?) \\ \t1
output! = SUCCESS
\end{schema} \\
\begin{classcom}
saveLocation corresponds to the private method in Board. It has two input-variables: absCoords, which is an absolute coordinate and robot, which is the robot that has been moved.  If we want to save the new location of the robot, the Tile that becomes the new location must be empty. The help-method put is used to place the robot on the empty Tile. After the location has been saved, the viewer is notified of the robot's location change, so it can redraw the Board.
\end{classcom} \\
\begin{schema}{saveLocation}
absCoords? : AbsoluteCoord \\
robot? : Robot
\where
\exists t : Tile | t.occupier = robot? \wedge t.clear\\
tiles(absCoords?).put(robot) \\
viewer.notifyView
\end{schema}
\znewpage
\begin{classcom}
Function to calculate the location of a robot according to it's path.
\end{classcom}\\
\begin{schema}{calculateNewLocation}
localCoords? : RelativeCoord \\
robot? : Robot \\
absoluteCoord : AbsoluteCoord \\
output! : (AbsoluteCoord \union Null)
\where
\IF checkPath(localCoords?, robot?) \\
\THEN absoluteCoord = firstConveyor(c, path) \\ \t1
\exists s : ConveyorDest | s.input? = absoluteCoord @ \\ \t2
output! = s.output! \\
\ELSE output! = Null.selfRef
\end{schema} \\
\begin{classcom}
Function to check if the path is free (if not, a ConveyorTile should be in front of the obstacle in order to let the path be valid). Calculate new coordinates as well
\end{classcom} \\
\begin{schema}{checkPath}
localCoords? : RelativeCoord \\
robot? : Robot \\
path : seq RelativeCoord \\
absoluteCoord : AbsoluteCoord \\
bool : \bool \\
output! : \bool
\where
bool = false \\
path = robot?.rule.possibleMoves(localCoords? \cross robots(robot?)) \\
\exists (c, t) : tiles | t.occupier = robot? \implies \\ \t1
\forall (int, coord) : path | \\ \t2
((addAbtoRel(c, coord) = Null \vee \\ \t2
(tiles(addAbtoRel(c, coord).type = BrokenRobotTile) \vee \\ \t2
\exists r: Robot | tiles(addAbtoRel(c, coord).occupier = r )\implies \\ \t3
\exists (int1, coord1) : path | int1 < int \\ \t3
tiles(addAbtoRel(c, coord1).type = ConveyorTile \\ \t3
absoluteCoord = addAbtoRel(c, coord1)) \implies \\ \t4
bool = \true \\ \t4
output! = bool
\end{schema} \\
\znewpage
\begin{classcom}
Calculate the first occuring ConveyorTile for a given path.
\end{classcom} \\
\begin{schema}{firstConveyor}
firstConveyor == (AbsoluteCoord \cross seq RelativeCoord) \fun \\ \t1 AbsoluteCoord
\where
\exists absoluteCoord : AbsoluteCoord |  \\ \t1
\exists (int, coord): seq RelativeCoord |  \\ \t2
(tiles(addAbtoRel(absoluteCoord, coord).type = conveyorTile \\ \t2
conveyorInPath(absoluteCoord, (int, coord)) = \\ \t3 addAbtoRel(absoluteCoord, coord)) \implies \\ \t3
\forall (int1, coord1): seq RelativeCoord | \\ \t3
\IF tiles(addAbtoRel(absoluteCoord, coord1).type = conveyorTile \\ \t3
\THEN int <= int1
\end{schema}
\end{class}

A BoardSnapshot is simply a copy of the current state of the board; therefore, the BoardSnapshot maintains a mapping of absolute coordinates to the tiles.
\begin{class}{BoardSnapshot}
\upharpoonright (tiles) \\
\begin{state}
tiles : \power (AbsoluteCoord \fun Tile) \\
\where
\forall t \ran tiles | t.isSnapshotTile
\end{state}
\end{class}

A Rule consists of a list of possible moves and a list of possible rotations. The possible moves are described in terms of local coordinates, since a robot does not know its exact location on the board. Since each robot has a certain rotation, possibleMoves maps relative coordinates and rotations to each possible relative coordinate that the robot can move to. The list of possible rotations is simply a list of all rotations.
\begin{class}{Rule}
\upharpoonright (possibleMoves, possibleRotations) \\
\begin{state}
possibleMoves : \power ((RelativeCoord \times Rotation) \psurj \\ \t1 \seq RelativeCoord) \\
possibleRotations : \power Rotation
\end{state} \\
\end{class}

A Robot has knowledge of the Controller and maintains a rule-attribute, describing the ruleset of the Robot.
\begin{class}{Robot}
\upharpoonright (rules) \\
\begin{state}
rules : Rules \\
controller : Controller
hint : Hints
\end{state}\\
\begin{classcom}
The initialize of the Robot uses the parameters controller and rules. The controller-parameter is the initialized Controller; the rules-parameter is the set of rules that determine the possible moves and rotations. In the initialize, all the provided input-values are saved and the list of hints is initially empty, since the Robot has not yet received any hints.
\end{classcom} \\
\begin{schema}{initialize}
\Delta (controller, rules, hint) \\
controller? : Controller \\
rules? : Rules
\where
controller' = controller? \\
rules' = rules? \\
hint' = Null.selfRef
\end{schema}\\
\begin{classcom}
NotifyAutoMovement is used by the Controller to notify that the Robot was moved, because of a conveyor belt. Note that the Robot could be rotated by a conveyor belt, so the list of hints is cleared; the Robot has now no idea where its Home Tile is.
\end{classcom} \\
\begin{schema}{notifyAutoMovement}
\Delta (hint)
\where
hint' = Null.selfRef
\end{schema}\\
\begin{classcom}
NotifyHint is used by the Controller to pass the hint of the Board to the Robot. Since each Robot may store a list with all the hints it has received, the new hint is simply added to the list of hints.
\end{classcom} \\
\begin{schema}{notifyHint}
\Delta (hint) \\
hint? : Hint
\where
hint' = \{hint?\} \union hint
\end{schema}
\end{class}

The Viewer has no knowledge of the Board; every change of the Board must be communicated to the Viewer via the Controller. The variable 'boardChanged' is used as a flag to indicate that the board has changed and the Viewer has not yet updated the view.
\begin{class}{Viewer}
\begin{state}
controller : Controller \\
boardChanged : \bool
\end{state}\\
\begin{classcom}
In initialize, the Viewer attaches itself to the Controller, using the addViewer-method; the viewer parameter in addViewer is this Viewer. ???
\end{classcom} \\
\begin{schema}{initialize}
\Delta (controller)
\where
\exists a : addViewer | a.viewer? = self \implies \\ \t1
a.output! = controller' \\ \t1
boardChanged' = \false
\end{schema}\\
\begin{classcom}
When the game has ended, the Viewer is notified by the Controller via notifyGameOver. The Viewer will now show an animation of fireworks and all robots that have not won the game will explode.
\end{classcom} \\
\begin{schema}{notifyGameOver}
robot? : Robot
\where
Fireworks
\end{schema}\\
\begin{classcom}
With notifyStateChange, the Viewer is notified by the Controller that the Board has changed. The Viewer sets boardChanged to true, to indicate that it has not yet updated the view.
\end{classcom} \\
\begin{schema}{notifyStateChange}
\Delta (boardChanged)
\where
boardChanged' = \true
\end{schema}\\
\znewpage
\begin{classcom}
The updateView-method uses the value of boardChanged to update the view. If this variable is true, then the Viewer requests a new snapshot from the Board, via the Controller, and updates the view. After the update, boardChanged is set to false. If boardChanged is false, then the previous snapshot is still up-to-date and nothing is changed. Note that the variable controller in Viewer never changes here, because it is simply used to request a board snapshot.
\end{classcom} \\
\begin{schema}{updateView}
\Delta (controller, snapShot)
\where
\IF boardChanged = \true \\
\THEN \exists r: requestBoardStatus | output! = snapShot' \\ \t1
boardChanged' = \false \\ \t1
controller' = controller \\
\ELSE snapShot' = snapShot \\ \t1
boardChanged' = \false \\ \t1
controller' = controller
\end{schema}
\end{class}

The controller has knowledge about the Board and the Viewer; it also maintains a list of the robots.
\begin{class}{Controller}
\begin{state}
board : Board \\
robots : \power Robot
viewer : Viewer
\end{state}\\
\begin{classcom}
addViewer corresponds to the public method in Controller. It takes a viewer as an input variable; this is the Viewer that wants to attach itself to the controller. If the Controller did not have a Viewer attached to it yet, then the Controller saves the Viewer and returns itself to the Viewer. The Viewer will then be able to address the controller, for board snapshot requests. If the Controller already had a Viewer attached to it, then the add-request is simply ignored.
\end{classcom} \\
\begin{schema}{addViewer}
\Delta (viewer) \\
viewer? : Viewer \\
output! : Controller
\where
\IF viewer = Null \\
\THEN viewer' = viewer? \\ \t1
output! = self \\
\ELSE output! = Null.selfRef
\end{schema}\\
\begin{classcom}
notifyAutoMovement corresponds to the public method in Controller. It takes the Robot that requested a move as input-parameter. This method is used by the Board to let the Robot know that it has been moved by a conveyor tile.
\end{classcom} \\
\begin{schema}{notifyAutoMovement}
robot? : Robot
\where
robot?.notifyAutomovement
\end{schema}\\
\znewpage
\begin{classcom}
moveRequest corresponds to the public method in Controller. It takes local coordinates, the Robot that requested the move and a rotation as input-parameters. The Controller forwards the move request of the robot, along with the specified attributes to the Board. If the Board then responds with "WIN", then the Controller must terminate all robots, notify the Viewer that the game has ended and terminate.
\end{classcom} \\
\begin{schema}{moveRequest}
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
ouput! : BoardResponse
\where
\exists m : Board.moveRequest | m.localCoords? = localCoords \\ \t1
m.robot? = robot? \\ \t1
m.rotation? = rotation? \\ \t1
m.output! = output! \\ \t1
\IF output! = WIN \\ \t1
\THEN \forall r : Robot | r.terminate \\ \t2
\exists n : viewer.notifyGameOver | n.robot? = robot? \\ \t2
board.canReset \\ \t2
terminate
\end{schema}\\
\begin{classcom}
Notify the controller of an appropriate hint.
\end{classcom} \\
\begin{schema}{notifyHint}
hint? : Hint \\
robot? : Robot
\where
\exists n : robot.notifyHint | n.hint? = hint?
\end{schema}\\
\begin{classcom}
Notify the viewer that the board has changed.
\end{classcom} \\
\begin{schema}{notifyView}
\where
\exists n : notifyStateChange
\end{schema}
\znewpage
\begin{classcom}
Initialize the controller so that it can be referred to.
\end{classcom} \\
\begin{schema}{preInitialize}
\Delta (board, robots, vieuwer)
\where
board' = Null.selfRef \\
robots' = Null.selfRef \\
viewer' = Null.selfRef
\end{schema}\\
\begin{classcom}
The real initialization of the controller, giving it a board and robots.
\end{classcom} \\
\begin{schema}{postInitialize}
\Delta (board, robots) \\
board? : Board \\
robots? : \power Robot
\where
board' = board \\
robots' = robots?
\end{schema}\\
\begin{classcom}
Remove a viewer (so that eventually, a new one can be added).
\end{classcom} \\
\begin{schema}{removeViewer}
\Delta (viewer, robots, board)
\where
viewer' = Null.selfRef \\
robots' = robots \\
board' = board
\end{schema}\\
\begin{classcom}
Function to get a snapshot of the board.
\end{classcom} \\
\begin{schema}{requestBoardStatus}
output! : BoardSnapShot
\where
\exists r : requestSnapShot | r.output! = output!
\end{schema}
\end{class}

\end{document}