\documentclass[12pt]{article}
\usepackage{oz-nolines}
\usepackage{listings, a4wide}
\lstset{breaklines=true, numbers=left}

\title{Report on OGO 2.2 Softwarespecification\\ Assignment 1a}
\author{
        Femke Jansen and Lasse Blaauwbroek OGO 2.2 group 6 \\
                Department of Computer Science\\
        Technical University Eindhoven\\
}
\date{\today}

\begin{document}

\maketitle

\section{Object-Z specification}
In this section the game is mathematically specified using the Object-Z language. Object-Z is a strict superset of the older Z language. This means that all features in Z are also present in Object-Z. Object-Z is used instead of Z because the specification is fairly large and became a little unmanageable in Z. Object-Z provides features to embedded schemas in classes. Those classes have visibility lists and can inherit other classes. This means there is more modularity, and it is easier to adhere to the class diagram.
Note that in the Z-specification, abbreviations are only used for dummy-variables; variables that refer to existing attributes or parameters in the class diagram are not abbreviated.

We begin with a few axiomatic definitions. Then we give the long list of classes and how they are defined. The classes follow the specification in the class diagram as good as possible.

\subsubsection{Basic Axiomatic definitions}
The Rotation set is used for orientation of robots and conveyor belts. The reason it use numbers instead of names as we do in the class diagram is because we will use them for arithmetics in one of the schemas. All rotations are counter clock-wise.
\begin{axdef}
Rotation == \{0, 90, 180, 270\}
\end{axdef}

BoardResponse is used by the Board and Controller to indicate the result of a move request or (implied) movement notifications. FAILED means that the requested move is illegal or impossible; SUCCESS means the move is successful executed; WIN indicates a successful move which resulted in a winning state.
\begin{axdef}
BoardResponse == \{FAILED, SUCCESS, WIN\}
\end{axdef}

Hint is a response that a robot receives, when he visits a hint tile.
\begin{axdef}
Hint == \{NORTH, NORTH\_EAST, EAST, SOUTH\_EAST, \\ \t1 SOUTH, SOUTH\_WEST, WEST, NORTH\_WEST\}
\end{axdef}

For ease of use, we define a null axiomatic definition as a element from a Null set. It is used when an empty return-value is preferred.
\begin{zed}
[Null]
\end{zed}
\begin{axdef}
null : Null
\end{axdef}

\subsubsection{Classes}

The Coord class is the base class of two types of coordinates. It consists of two public integers representing the x and y values.
For sake of breviaty the Coord class is introduced in the Z-specification. It is used in both AbsoluteCoord and RelativeCoord; an absolute coordinate can now be expressed by restricting the values of x and y to values in the interval [0, BoardWidth). Note that this class is not shown in the class diagram, since that would not add any functionality to the class diagram. This specification uses computer coordinates with the y axis pointing downwards.

The Coord class contains the width and height-variables from the Board; these variables are in fact the attributes of Board in the class diagram. In order to keep the Z-specification readable and easier to model, these attributes were placed in the Coord class.
\begin{class}{Coord}
\upharpoonright (x, y) \\
\begin{state}
x : \num \\
y : \num
\end{state} \\
\end{class}

This class is used to point to a specific tile on the board.
\begin{class}{AbsoluteCoord}
Coord \\
\begin{zpar}
The BoardWith and BoardHeight variables are static and final. They specify the dimensions of the board.
\end{zpar} \\
\begin{axdef}
BoardWith, BoardHeight : \nat
\end{axdef} \\
\begin{state}
\where
0 \leq x < BoardWidth \\
0 \leq y < BoardHeight
\end{state}
\end{class}

The RelativeCoord class is a specialization of the Coord class. There are restrictions nor additions to the base class. It is effectively only a rename. This class is used to specify a location on the board relative to a AbsoluteCoord.
\begin{class}{RelativeCoord}
Coord \\
\end{class}

The Tile class is the representation of one tile on the board. The tiles are managed by the board. The class keeps track of which robot currently occupies the tile. To differentiate between different kind of tiles, the Tile class is the base class of several specializations.
 
\begin{class}{Tile}
\upharpoonright (occupier) \\
\begin{zpar}
The occupier variable indicates which robot currently resides on this tile. If the tile is empty, the variable is $null$. The private isSnapShotTile-member indicates that the tile is in fact a copy from a board; if the value is true, it is thus part of a BoardSnapshot-object. This distinction is convenient for the Z specification because this way it can represent clones of the board that contain different tile instances but in fact represent the same board.
\end{zpar} \\
\begin{state}
occupier : Robot \cup \{null\} \\
isSnapshotTile : \bool \\
\end{state} \\
\begin{zpar}
Initially, no robots have been placed yet, so the occupied-variable has value $null$.
\end{zpar}
\begin{schema}{Init}
occupier = null
\end{schema} \\
\begin{zpar}
The clear schema is used by schemas defined in other classes to remove the current occupying robot from the tile. (This schema is required because schemas can never change the state of a class on which they are not defined in object-Z)
\end{zpar} \\
\begin{schema}{clear}
\Delta (occupier) \\
\where
occupier' = Null
\end{schema} \\
\begin{zpar}
The put schema has is defined for the same reason as the clear schema. It places the given robot on the tile.
\end{zpar}\\
\begin{schema}{put}
\Delta (occupier) \\
input? : Robot
\where
occupier' = input?
\end{schema} \\
\begin{zpar}
The rotate schema is empty; it can be seen as a abstract schema. This schema is overridden by Conveyor Tile, since a conveyor tile is the only tile that can change its rotation. In all other types of tiles, the schema is just empty.
\end{zpar} \\
\begin{schema}{rotate}
\Delta()
\end{schema}
\end{class}

A NormalTile is a subclass of Tile  a tile with no special meaning.
\begin{class}{NormalTile}
Tile
\end{class}

The HintTile class is also subclass of tile. It is only renamed to indicate the board should produce a hint when a robot occupies it.
\begin{class}{HintTile}
Tile
\end{class}

A BrokenRobotTile is a (static) tile that contains a broken robot that prohibits other robots from visiting this tile; hence, the class has an additional invariant that makes sure no robot can ever occupy this tile.
\begin{class}{BrokenRobotTile}
Tile \\
\begin{state}
occupier = Null
\end{state}
\end{class}

A HomeTile is a tile that a (specific) robot has to visit in order to win the game. 
\begin{class}{HomeTile}
Tile \\
\upharpoonright (target) \\
\begin{state}
target : Robot
\end{state}
\end{class}

A ConveyorTile is a tile that automatically transports a robot to another tile, when a robot visits this tile. It may also rotate the robot.
\begin{class}{ConveyorTile}
Tile \\
\upharpoonright (rotation) \\
\begin{state}
rotation : Rotation
\end{state} \\
\begin{zpar}
This is the overridden schema of the base class. It changes the orientation of the conveyor. There is no invariant present in the variable since the resulting orientation will in an arbitrary direction.
\end{zpar} \\
\begin{schema}{rotate}
\Delta (rotation)
\end{schema}
\end{class}

The Board class maintains is the biggest class. It maintains most of the global invariants and handles all of the requests by the other classes.
\begin{class}{Board}
\upharpoonright (Init, initialize, requestTilesExchange, canReset, initialize) \\
\begin{nobottomstate}
\begin{zpar}
The tiles variable if a function from all possible absolute coordinates of the board to a tile or one of its subclasses.
\end{zpar} \\
tiles : \power (AbsoluteCoord \fun \: \downarrow \! Tile) \\
\also \also \also
\begin{zpar}
The robots function assigns a rotation to every robot in the game.
\end{zpar} \\
robots : \power (Robot \pfun Rotation) \\
\also \also \also
controller : Controller \\
\also \also \also
\begin{zpar}
The occupied variable is a set of all coordinates in the board currently occupied by either a living robot or a broken robot.
\end{zpar} \\
occupied : \power AbsoluteCoord \\
\also \also \also
\begin{zpar}
The adjacent relation relates all coordinates in the board directly adjacent to each other. In case the second coordinate is occupied, it does not relate to any variable.
This means the relation is asymmetric. This is done to relate all free adjacent tiles tiles to a robot.
\end{zpar} \\
adjacent : \power (AbsoluteCoord \rel AbsoluteCoord) \\
\also \also \also
\begin{zpar}
This function relates all coordinates with a conveyor tile to the destination of that tile (not the destination of the whole conveyor).
\end{zpar} \\
conveyorUnitDest : \power (AbsoluteCoord \pinj AbsoluteCoord) \\
\also \also \also
\begin{zpar}
The conveyorDest function gives the destination of a whole conveyor belt.
\end{zpar} \\
conveyorDest : \power (AbsoluteCoord \pinj AbsoluteCoord)
\where
\begin{zpar}
Enforce that none of the tiles are snapshot tiles.
\end{zpar} \\
\forall t : \ran tiles | \neg t.isSnaphotTile
\also \also \also
\begin{zpar}
This is the invariant of the occupied variable.
\end{zpar} \\
occupied = \{c : AbsoluteCoord | \\ \t1 tiles(c) \in BrokenRobotTile \vee
tiles(c).occupier \not = Null\} \\
\end{nobottomstate} \\
\znewpage
\begin{notopstate}
\begin{zpar}
The invariant for the conveyorUnitDest function.
\end{zpar} \\
conveyorUnitDest = \{(c1, c2) : AbsoluteCoord \times AbsoluteCoord | \\ \t1 c2 \not \in occupied \wedge tiles(c1) \in ConveyorTile \; \; \wedge \\ \t1
        tiles(c1).rotation = 0 \Rightarrow (c1.x = c2.x + 1 \wedge c1.y = c2.y) \; \; \wedge \\ \t1
        tiles(c1).rotation = 90 \Rightarrow (c1.x = c2.x \wedge c1.y = c2.y - 1) \; \; \wedge \\ \t1
        tiles(c1).rotation = 180 \Rightarrow (c1.x = c2.x - 1 \wedge c1.y = c2.y) \; \; \wedge \\ \t1
        tiles(c1).rotation = 270 \Rightarrow (c1.x = c2.x \wedge c.y = c2.y + 1)\}
\also \also \also
\begin{zpar}
The invariant for the conveyorDest function. It is defined as the transitive closure of conveyorUnitDest but requires the second variable not to be
an ConveyorTile. This way, the function only points to the end of the conveyor belt.
The only exception to this rule is when the belt is blocked. In this case, $conveyorUnitDest(c2) = c2$ holds.
\end{zpar} \\
conveyorDest = \{(c1,c2) : AbsoluteCoord \times AbsoluteCoord | \\ \t1 (c1, c2) \in conveyorUnitDest \star \; \; \wedge \\ \t1 (tiles(c2) \not \in ConveyorTile \vee conveyorUnitDest(c2) = c2)\}
\also \also \also
\begin{zpar}
The invariant for the adjacent relation.
\end{zpar} \\
adjacent = \{(c1, c2) : AbsoluteCoord \times AbsoluteCoord | \\ \t1 |\!c1.x - c2.x\!| + |\!c1.y - c2.y\!| = 1 \wedge c2 \not \in occupied\}
\also \also \also
\begin{zpar}
This invariant requires every robot to have a reachable HomeTile.
The transitive closure on the union between the adjacent relation and the conveyorDest function
provides a relation between every reachable pair of coordinates. The invariant maintains that the coordinatepair of every robot and its HomeTile are reachable.
\end{zpar} \\
\forall r : robots | \exists c, d : \dom tiles @  \\ \t1 tiles(c) \in HomeTile \wedge tiles(c).target = r \; \; \wedge \\ \t1
d.occupier = r \wedge (c, d) \in (adjacent \cup conveyorDest)\star
\also \also \also
\begin{zpar}
There should be a minimum of two robots, and at least one robot with rule set A and one robot with rule set B
\end{zpar} \\
\exists r : \dom robots | r.rule = RuleA \\
\exists r : \dom robots | r.rule = RuleB
\end{notopstate} \\
\begin{schema}{Init}
reset
\end{schema} \\
\znewpage
\begin{zpar}
Initialize is called from the outside world, when a new game has to be
started. The method first calls an internal initializer. This initializes every variable.
Then a preInitialize of the controller is called. In Z, this is not necessary but ordinary programming languages would need it to retrieve a pointer to the instance of controller.
After the preInitialize, all robots are initialized. They need a rule (either RuleA or RuleB) and the controller as arguments.
Then the controller is postInitialized, with the set of initialized robots and the board itself as arguments.
After everything is initialized, all robots get a command to commence playing.
\end{zpar} \\
initialize \sdef internalInit \comp controller.preInitialize \; \comp \\ \t1
[rule? : Rule | rule? \in \{RuleA, RuleB\}] @ \\ \t3 \bigwedge_{r : dom Robots} r.initialize[controller?/controller] \; \comp \\ \t1
controller.postInitialize[board?/self, robots?/\dom robots] \; \; \comp \\ \t1
\bigwedge_{r : dom Robots} r.play
\also \also \also
\begin{zpar}
The internal initializer makes sure the variables of board are initialized to something else than Null.
\end{zpar} \\
\begin{schema}{internalInit}
\Delta (tiles, robots, controller)
\where
tiles' \not = Null \\
robots' \not = Null \\
controller' \not = Null
\end{schema} \\
\znewpage
\begin{zpar}
CanReset is used by the Controller to let the Board know that the game has ended and that the Board can reset. The Board can reset whenever there is HomeTile on the Board that is occupied by the target robot.
\end{zpar} \\
canReset \sdef [\exists t : \ran tiles | t \in HomeTileTiles @ \\
\t1 t.target = t.occupier] \wedge reset \\
\begin{zpar}
When the Board resets itself, the tiles, the controller and the robots are set to Null.
\end{zpar} \\
\begin{schema}{reset}
\Delta (tiles, robots. controller)
\where
tiles' = Null \\
robots' = Null \\
controller' = Null
\end{schema} \\
\begin{zpar}
This schema creates a snapshot of the current situation of the board.
It does so by requiring all tiles in the snapshot to have exactly the
same state as the current state of the tiles of the board. The only
exception is that the snapshot variable of the tiles must be true.
This way, we make sure the instances of the tiles of the snapshot are different from
the instances from the tiles of the board.
\end{zpar} \\
\begin{schema}{requestSnapShot}
snapshot? : BoardSnapshot
\where
\forall (c1,t1) : tiles | \exists (c2,t2) : snapshot? | c1 = c2 \: \wedge \\ \t2
t1.occupier = t2.occupier \: \wedge \\ \t2
t1 \in NormalTile \Rightarrow t2 \in NormalTile \: \wedge \\ \t2
t1 \in HintTile \Rightarrow t2 \in HintTile \: \wedge \\ \t2
t1 \in BrokenRobotTile \Rightarrow t2 \in BrokenRobotTile \: \wedge \\ \t2
t1 \in HomeTile \Rightarrow (t2 \in HomeTile \wedge t1.target = t2.target) \: \wedge \\ \t2
t1 \in ConveyorTile \Rightarrow \\ \t3 (t2 \in ConveyorTile \wedge t2.rotation = t2.rotation)
\end{schema} \\
\znewpage
\begin{zpar}
sendPossibleHint is used by other Z schemas to sent a hint whenever
a move request is completed. It checks whether the robot it receives in its
parameters is actually on a HintTile, and if this is the case, it get a hint
and sends it to the controller.
To determine whether a hint should be sent is done using nondeterminism.
The preconditions of both schema's that can be chosen from are contradictory.
This means that only one of the schema's can be chosen at all times,
eliminating the nondeterminism.
\end{zpar} \\
sendPossibleHint \sdef [robot? : Robot | \\ \t2 \neg \exists c : \ran tiles | c \in HintTile \wedge c.occupier = robot?] \; \; [] \\ \t1
[robot? : Robot | \exists c : \ran tiles | c \in HintTile \wedge c.occupier = robot?] \; \; \wedge \\ \t1 (getHint \comp controller.notifyHint) \\
\begin{zpar}
This schema retrieves a hint for a given robot.
\end{zpar} \\
\begin{schema}{getHint}
robot? : Robot \\
output!: Hint \\
\delta x : \{-1, 0, 1\} \\
\delta y : \{-1, 0, 1\} \\
numRotations : \nat
\where
\begin{zpar}
This variable determines what the rotation of the robot is in terms
of 90 degrees. For example, for a robot with a rotation of 270 degrees
the variable will contain the number three.
\end{zpar} \\
numRotations = \frac{robots(robot?)}{90} \\
\also \also \also
\begin{zpar}
In this invariant, the current tile of the robot and the home tile of the robot
are determined. Then the (manhattan) direction the robot has to move to reach
the home tile is determined and stored in the $\delta x$ and $\delta y$
variables. A hint is then retrieved according to this direction using the
hintMapping function defined below. This hint is then rotated a number of times
until it conforms with the direction the robot faces.
\end{zpar} \\
\exists c1,c2 : \ran tiles, h : Hint | \\ \t1 c1 \in HomeTile \wedge
 tiles(c1).target = robot? \; \; \wedge \\ \t1 tiles(c2).occupier = robot? \wedge
 \delta x = \frac{c1.x - c2.x}{|c1.x - c2.x|} \wedge \delta y = \frac{c1.y - c2.y}{|c1.y - c2.y|} \; \; \wedge \\ \t1
 h \in robot.hintMapping(\delta x, \delta y) \; \; \wedge \\ \t1
 output! = rotate90Deg^{numRatations}(h)
\end{schema} \\
\znewpage
\begin{zpar}
This axiomatic function maps a (manhattan) direction to a set of suitable
hints.
\end{zpar} \\
\begin{axdef}
hintMapping : \power ((\{-1, 0, 1\} \cross \{-1, 0, 1\}) \pfun \power Hint)
\where
hintMapping(-1, -1) = \{NORTH\_WEST, NORTH, WEST\} \\
hintMapping(-1, 0) = \{WEST\} \\
hintMapping(-1, 1) = \{SOUTH\_WEST, SOUTH, WEST\} \\
hintMapping(0, -1) = \{NORTH\} \\
hintMapping(0, 1) = \{SOUTH\} \\
hintMapping(1, -1) = \{NORTH\_EAST, NORTH, EAST\} \\
hintMapping(1, 0) = \{EAST\} \\
hintMapping(1, 1) = \{SOUTH\_EAST, SOUTH, EAST\} \\
\end{axdef} \\
\begin{zpar}
This axiomatic function rotates a given hint 90 degrees.
\end{zpar} \\
\begin{axdef}
rotate90Deg : \power (Hint \fun Hint)
\where
rotate90Deg(NORTH) = WEST \\
rotate90Deg(WEST) = SOUTH \\
rotate90Deg(SOUTH) = EAST \\
rotate90Deg(EAST) = NORTH \\
rotate90Deg(NORTH\_EAST) = NORTH\_WEST \\
rotate90Deg(NORTH\_WEST) = SOUTH\_WEST \\
rotate90Deg(SOUTH\_WEST) = SOUTH\_EAST \\
rotate90Deg(SOUTH\_EAST) = NORTH\_EAST
\end{axdef} \\
\znewpage
\begin{zpar}
This schema must be called everytime something changes on the board. It makes sure that if there are robots that were previously blocked are moved to their destination. The schema that actually moves the robot is moveBlockedRobot and is described below. This schema is called first, and then the schema is called recursive. There is a schema that is nondeterministically called, but only when there is no robot left to move. If this schema is called, the recursion stops. After the recursion, the viewer is notified of the change.
\end{zpar} \\
moveBlockedRobotsRecursive \sdef ((moveBlockedRobot \; \; \comp \\ \t1 moveBlockedRobotsRecursive) \; \; [] \\ \t1 [\neg \exists (c,t) : tiles | \\ \t2 t \in ConveyorTile \wedge t.occupier \not = Null \wedge conveyorDest(c) = c]) \; \; \comp \\ \t1 notifyView \\
\also \also \also
\begin{zpar}
This schema moves one unblocked robot to its destination. It first finds two tiles for which the first tile is a conveyor tile and has an robot that occupies it. The second tile is the destination of the conveyor belt. It then moves the robot from the first tile to the second tile. If the new location of the robot is its hometile, it sends a WIN response along with the notifyAutomovement, else it sends a SUCCESS response.
\end{zpar} \\
moveBlockedRobot \sdef [c1, c2 : \dom tiles, r : \dom robots, \\ \t1 response : BoardResponse | \\ \t1 tiles(c1) \in ConveyorTile \wedge tiles(c1).occupier = r \; \; \wedge \\ \t1 conveyorDest(c1) \not = c1 \wedge conveyorDest(c1) = c2 \; \; \wedge \\ \t1
(\IF tiles(c2) \in HomeTile \wedge tiles(c2).target = r \\ \t1
\THEN response = WIN \\ \t1
\ELSE response = SUCCESS)] @ \\ \t2 c1.clear \wedge c2.put[input?/r] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/r] \\
\also \also \also
\begin{zpar}
This schema processes a request to exchange two tiles using the getValidTiles schema. It first requests two valid tiles, then it actually exchanges those tiles using the exchangeTiles schema.
This schema returns the two tiles is has exchanged. The returned tiles are then rotated. If there are robots present, they should
be notified of the exchange. The notifyAutomovement schema of controller is always called, even when the robot is null. It is the responsibility of the controller not to forward the message in this case.
After the whole request is processed, the moveBlockedRobotRecursive schema is called to move al unblocked robots. Then the viewer is notified of the change.
\end{zpar} \\
requestTilesExchange \sdef (getValidTiles \comp exchangeTiles \; \; \comp \\
\t1 [t1, t2 : Tile, response : BoardResponse | \\ \t1 t1 = exchangedPair?.0 \wedge t2 = exchangedPair?.1 \; \; \wedge \\ \t1 response = SUCCESS] @ \\ \t2 t1.rotate \wedge t2.rotate \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/t1.occupier] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/t2.occupier]) \; \; \comp \\ \t1 moveBlockedRobotRecursive \comp notifyView \\
\znewpage
\begin{zpar}
The output of this schema is a pair of two tiles that can be exchanged. The schema makes sure the invariants of the board will still hold when the tiles are exchanged. A tile is valid for an exchange if it is not a HomeTile or a HintTile.
Tho check whether the invariants of the board still hold when the tiles
are exchanged, it checks if there exists a board with exact the same state,
except for the exchanged tiles. To make sure this board has the same state, not only the state of the variables
needs to be checked, but also the states of the instances every variable references.
\end{zpar} \\
\begin{schema}{getValidTiles}
tilePair! : Tile \cross Tile
\where
\exists b : Board, (c1, t1), (c2, t2) : tiles | \\ \t1
b.robots = robots \;\; \wedge \\ \t1
 b.tiles = (tiles \setminus \{(c1, t1), (c2, t2)\}) \cup \{(c1, t2), (c2, t1)\} \\ \t1
t1 \not = t2 \; \;  \wedge \\ \t1
t1 \not \in HomeTile \wedge t1 \not \in HintTile \; \; \wedge \\ \t1
t2 \not \in HomeTile \wedge t2 \not \in HintTile \; \; \wedge \\ \t1
\forall t : \ran tiles | \\ \t2 t.occupier = tiles(b.tiles^{-1}(t)).occupier \; \; \wedge \\ \t2 t \in HomeTile \Rightarrow t.target = tiles(b.tiles^{-1}(t)).target \;\; \wedge \\\t1
tilePair! = (t1, t2)
\end{schema} \\
\begin{zpar}
This method exchanges two given tiles, and outputs the tiles it has exchanged for further processing. It first finds the coordinates corresponding to the tiles. Then it exchanges the tiles by removing the old coordinate/tile pairs from the tiles variable and adding new pairs where the tiles are exchanged.
\end{zpar} \\
\begin{schema}{exchangeTiles}
\Delta(tiles, robots) \\
tilePair? : Tile \cross Tile \\
exchangedPair! : Tile \cross Tile \\
\where
tilePair? = exchangedPair! \\
\also \also \also
\exists c1, c2 : \dom tiles | tiles(c1) = tilePair?.0 \wedge tiles(c2) = tilePair?.1 \; \; \wedge \\ \t1
tiles' = tiles \setminus \{(c1, tilePair?.0),(c2, tilePair?.1)\} \cup \\ \t2 \{(c1, tilePair?.1),(c2, tilePair?.0)\}
\end{schema} \\
\znewpage
\begin{zpar}
This schema processes a move request. It calls either moveRotate or moveWalk, depending on whether the rotation parameter or the localCoords parameter is null.
\end{zpar} \\
moveRequest \sdef ([localCoords? : RelativeCoord \cup Null, \\ \t1 rotation? : Rotation \cup Null | \\ \t2 localCoords? = null] \wedge moveRotate) \; \; [] \\ \t1
([localCoords? : RelativeCoord \cup Null, \\ \t1 rotation? : Rotation \cup Null | \\ \t2 localCoords = null] \wedge moveWalk) \\
\begin{zpar}
This schema rotates a robot. If there is a rule in the robots rule set allowing the rotation, it is executed and a SUCCESS is returned. Else, a FAILED board response is returned.
\end{zpar} \\
\begin{schema}{moveRotate}
\Delta(robots) \\
robot? : Robot \\
rotation? : Rotation \\
response! : BoardResponse
\where
\IF \exists r : robot?.rule.possibleRotations | r = rotation?\\
\THEN response! = SUCCESS \; \; \wedge \\ \t1
robots'(robot?) = (robots(robot?) + rotation?) \mod 360 \\
\ELSE response! = FAILED \wedge robots' = robots
\end{schema} \\
\znewpage
\begin{zpar}
This schema moves a robot to a new tile. It first calls a moveWalkPre subschema. This schema determines whether the move is allowed, and where the robot should be moved. It outputs a putTile, robot, beginTile, response, and autoMovement variable. If the response is WIN or SUCCESS, the begin tile is cleared of the robot, and the robot is put on the putTile tile. Then the view is notified and the robot is notified about a possible hint.
If the autoMovement variable is true, it means the robot has crossed a conveyor belt and should be notified. When the robot is moved, the moveBlockedRobotsRecursive schema is called to move all unblocked robots.
\end{zpar} \\
moveWalk \sdef moveWalkPre \; \; \comp \\ \t1 (([response? = FAILED] \; \; [] \\ \t2 [response? = SUCCESS \vee response? = WIN] \;\; \wedge \\ \t2 begintTile?.clear \; \; \wedge \\ \t2 putTile?.put[input?/robot?] \wedge notifyView \wedge sendPossibleHint) \; \; \wedge \\ \t1 ([autoMovement? = \false] \; \; [] \\ \t2 ([autoMovement? = \true] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/robot?]))) \; \; \comp \\ \t1
moveBlockedRobotsRecursive \\
\begin{zpar}
This function is needed for the moveWalkPre schema. It rotates a sequence of relative coordinates clockwise 90 degrees.
\end{zpar} \\
\begin{axdef}
rotatePath : \power (\seq RelativeCoord \fun \seq RelativeCoord)
\where
\forall s : \seq RelativeCoord | \forall (n, c) : rotatePath(s) | \\ \t1
s(n).x = c.y \wedge s(n).y = -c.x
\end{axdef} \\
\begin{zpar}
This schema is a helper of the moveWalk schema. It calculates whether a move is allowed, and on which tile the robot would be placed when the move would be executed. It is a very long and difficult schema.
\end{zpar} \\
\begin{nobottomschema}{moveWalkPre}
\begin{zpar}
The relative coordinates the robot should be moved to.
\end{zpar} \\
localCoords? : RelativeCoord \\
\begin{zpar}
The robot that should be moved.
\end{zpar} \\
robot? : Robot \\
\begin{zpar}
The response that should be given.
\end{zpar} \\
response! : BoardResponse \\
\begin{zpar}
The tile the robot should be moved to.
\end{zpar} \\
putTile! : Tile \cup Null \\
\begin{zpar}
The tile the robot is currently on.
\end{zpar} \\
beginTile! : Tile \\
\begin{zpar}
A variable indicating whether the robot is going moved by a conveyor belt.
\end{zpar} \\
autoMovement! : \bool \\
\end{nobottomschema}
\znewpage
\begin{nobothschema}
\begin{zpar}
A helper function giving the sequence number of the coordinate in a sequence of coordinates on which the path is blocked by either a broken robot tile or another robot. If the path is not blocked, the function outputs minus one.
\end{zpar} \\
pathBlockedOn : \power (\seq AbsoluteCoord \fun \nat) \\
\begin{zpar}
A helper function giving the sequence number of the coordinate in a sequence of coordinates that is the first conveyor tile in the sequence. If there is not conveyor tile in the sequence the function outputs minus one.
\end{zpar} \\
firstConveyor : \power (\seq AbsoluteCoord \fun \nat) \\
\begin{zpar}
This helper function adds a sequence of relative coordinates to the absolute coordinates the robot is currently on and returns a sequence of absolute coordinates.
\end{zpar} \\
relativeToAbsolute : \power (\seq RelativeCoord \pfun \seq AbsoluteCoord) \\
\begin{zpar}
This function indicates whether if the robot is moved to a tile, it will be a valid move.
\end{zpar} \\
validMove : \power (Tile \fun \bool) \\
\begin{zpar}
This variable stores the relative path the robot has to follow.
\end{zpar} \\
relativePath : \power \seq RelativeCoord\\
\begin{zpar}
This variable stores the absolute path the robot has to follow.
\end{zpar} \\
absolutePath : \power \seq AbsoluteCoord \cup Null\\
\begin{zpar}
A variable indicating the move is allowed.
\end{zpar} \\
moveValid : \bool \\
\begin{zpar}
The number of rotations of the robot in terms of 90 degrees.
\end{zpar} \\
numRotations : \nat
\where
numRotations = \frac{robots(robot?)}{90}
\also \also \also
\begin{zpar}
The occupier of the begin tile needs to be occupied by the robot.
\end{zpar} \\
beginTile!.occupier = robot?
\also \also \also
\begin{zpar}
This is the invariant maintaining the pathBlockedOn function. If there is a coordinate in the sequence that is occupied and there is not coordinate with a lower sequence number that is also occupied, the function should output the sequence number of that coordinate. If there are no blocked tiles on the path, the function returns minus one.
\end{zpar} \\
\forall s : \power \seq AbsoluteCoord | \\ \t1
 \IF \exists (n, c) : s | occupied(c) \\ \t1
 \THEN \exists (n1, c1) : s | n1 = pathBlockedOn(s) \wedge occupied(c) \; \; \wedge \\ \t6
 (\neg \exists (n2, c2) : s | occupied(c) \wedge n2 < n1) \\ \t1
 \ELSE pathBlockedOn(s) = -1
\also \also \also
\begin{zpar}
The invariant of the firstConveyor. If there is a conveyor tile in the sequence that is not occupied and there is no other unoccupied conveyor tile with a smaller sequence number, the firstConveyor function should output the sequence number of that tile. If there is no conveyor tile, it outputs minus one.
\end{zpar} \\
\forall s : \power \seq AbsoluteCoord | \\ \t1
 \IF \exists (n,c) : s | c \in ConveyorTile \wedge \neg occupied(c) \\ \t1
 \THEN \exists (n1,c1) : s | n1 = firstConveyor(s) \; \; \wedge \\ \t6 c1 \in ConveyorTile \wedge \neg occupied(c1) \; \; \wedge \\ \t6
 (\neg \exists (n2,c2) : s | c2 \in ConveyorTile \; \; \wedge \\ \t9 \t1 \neg occupied(c2) \wedge c2 < c1) \\ \t1
 \ELSE firstConveyor(s) = -1
\end{nobothschema}
\znewpage
\begin{nobothschema}
\begin{zpar}
The invariant for the relativeToAbsolute function. It simply adds the begintTile coordinate to all of the relative coordinates creating a sequence of absolute coordinates.
\end{zpar} \\
\forall (s1, s2) : relativeToAbsolute | \forall n : \dom s1 | \\ \t1 s2(n).x = s1(n).x + beginTile!.x \; \; \wedge \\ \t1 s2(n).y = s1(n).y + beginTile!.y
\also \also \also
\begin{zpar}
The relativePath variable is equalled to the path required to follow by the rule set. If there is no possible move to the relative coordinates, relativePath becomes null.
\end{zpar} \\
\IF (localCoords?) \in \dom (robot?.rule.possibleMoves) \\
\THEN relativePath = \dom (robot?.rule.possibleMoves(localCoords?) \\
\ELSE relativePath = null \\
\also \also \also
\begin{zpar}
This invariant rotates the relative path to the rotation of the robot and checks whether this path falls within the boards dimensions. If this is the case, it is assigned to absolutePath. Else absolutePath is null.
\end{zpar} \\
\IF relativePath \not = null \; \; \wedge \\ \t1 rotatePath^{numRotations}(relativePath) \in \dom relativeToAbsolute \\
\THEN absolutePath = relativeToAbsolute(
rotatePath^{numRotations}(relativePath)) \\
\ELSE absolutePath = Null
\also \also \also
\begin{zpar}
This invariant maintains the validMove function. It checks whether there exists a board for which every variable is equal to the present variable, but the robot is moved from the beginTile to the given tile.
\end{zpar} \\
\forall t : Tile | validMove(t) = \exists b : Board | \\ \t2
    b.robots = robots \wedge b.tiles = tiles \; \; \wedge \\ \t1 b.tiles(beginTile!).occupier = Null \wedge b.tiles(t).occupier = robot? \; \; \wedge \\ \t1 \forall t : (\ran tiles) \setminus \{beginTile!, t\} | \\ \t2 t.occupier = tiles(b.tiles^{-1}(t)).occupier \; \; \wedge \\ \t2 t \in HomeTile \Rightarrow t.target = tiles(b.tiles^{-1}(t)).target
\end{nobothschema}
\znewpage
\begin{notopschema}
\begin{zpar}
This invariants determines whether the move is valid, where the robot should be put and if there occurs an auto movement. If the path is blocked, and there is no conveyor before the block, the move is invalid. If there is a conveyor on the path, the move is valid, and there is auto movement. If there is no block and no conveyor tile the move is valid, and there has not been auto movement. In all other cases, the move is not valid.
\end{zpar} \\
\IF absolutePath = null \vee (pathBlockedOn(absoltePath) \not = -1 \; \;\wedge \\ \t1 (firstConveyor(absolutePath) = -1 \; \; \vee \\ \t2 firstConveyor(absolutePath) > pathBlockedOn(absolutePath)) \\
\THEN moveValid = \false \; \; \wedge putTile! = Null \wedge autoMovement! = \false \\
\ELSE \IF firstConveyor(absolutePath) \not = -1 \; \; \wedge \\ \t1 validMove(conveyorDest(firstConveyor(absolutePath))) \\
\THEN moveValid = \true \wedge autoMovement! = \true \;\; \wedge \\ \t1 putTile! = conveyorDest(firstConveyor(absolutePath) \\
\ELSE \IF validMove(absolutePath(\#absolutePath - 1)) \\
\THEN moveValid = \true \wedge autoMovement! = \false \; \; \wedge \\ \t1  putTile! = absolutePath(\#absolutePath - 1) \\
\ELSE moveValid = \false \wedge autoMovement! = \false \wedge putTile! = null \\
\also \also \also
\begin{zpar}
This invariant determines the value of the response.
\end{zpar} \\
\IF moveValid = \true \wedge putTile! \in HomeTile \wedge putTile!.target = robot? \\
\THEN response! = WIN \\
\ELSE \IF moveValid = \true \\
\THEN response! = SUCCESS \\
\ELSE response! = FAILED
\end{notopschema} \\
\end{class}

A BoardSnapshot is simply a copy of the current state of the board; therefore, the BoardSnapshot maintains a mapping of absolute coordinates to the tiles. The only invariant it maintains is that every tile should be a snapshot tile in order to differentiate between normal tiles.
\begin{class}{BoardSnapshot}
\upharpoonright (tiles) \\
\begin{state}
tiles : \power (AbsoluteCoord \fun Tile) \\
\where
\forall t \ran tiles | t.isSnapshotTile
\end{state}
\end{class}

A Rule consists of a list of possible moves and a list of possible rotations. The possible moves are described in terms of local coordinates, since a robot does not know its exact location on the board. The coordinates are relative to the rotation of the robot. For example, when a robot is rotated 90 degrees, and has a rule to move forward, it moves to the right.
\begin{class}{Rule}
\upharpoonright (possibleMoves, possibleRotations) \\
\begin{state}
possibleMoves : \power (RelativeCoord \pfun \seq RelativeCoord) \\
possibleRotations : \power Rotation
\where
\forall (c, r) : \dom possibleMoves | \\ \t1 possibleMoves(c,r)(\#possibleMoves(c, r) - 1) = c
\end{state} \\
\end{class}
\begin{zpar}
\end{zpar} \\
\begin{axdef}
RuleA : Rule
\where
RuleA.possibleRotations = \emptyset \\
\forall (c, s) : RuleA.possibleMoves | |c.x + c.y| = 1 \wedge s = \langle c\rangle
\end{axdef}

\begin{axdef}
RuleB : Rule
\where
RuleB.possibleRoations = \{0, 90, 180, 270\} \\
\forall (c1, s) : RuleB.possibleMoves | c1.y = 0 \wedge 0 < c1.x \leq 3 \wedge c1.x = \#s \; \; \wedge \\ \t1 \forall (n, c2) : s | c2.y = 0 \wedge c2.x = n
\end{axdef}

A Robot has knowledge of the Controller and maintains a rule-attribute, describing the ruleset of the Robot.
\begin{class}{Robot}
\upharpoonright (rules) \\
\begin{state}
rules : Rule \\
controller : Controller \\
hints : \power Hints
\end{state}\\
\begin{schema}{Init}
rules = Null \\
controller = Null \\
hints = Null
\end{schema} \\
\begin{zpar}
The initialize of the Robot uses the parameters controller and rules. The controller-parameter is the initialized Controller; the rules-parameter is the set of rules that determine the possible moves and rotations. In the initialize, all the provided input-values are saved and the list of hints is initially empty, since the Robot has not yet received any hints.
\end{zpar} \\
\begin{schema}{initialize}
\Delta (controller, rules) \\
controller? : Controller \\
rules? : Rules
\where
controller' = controller? \\
rules' = rules?
\end{schema} \\
\begin{zpar}
NotifyAutoMovement is used by the Controller to notify that the Robot was moved, because of a conveyor belt. Note that the Robot could be rotated by a conveyor belt, so the list of hints is cleared; the Robot has now no idea where its Home Tile is.
\end{zpar} \\
\begin{schema}{notifyAutoMovement}
\Delta (hint)
response? : BoardResponse
\where
hint' = \emptyset
\end{schema}\\
\begin{zpar}
NotifyHint is used by the Controller to pass the hint of the Board to the Robot. Since each Robot may store a list with all the hints it has received, the new hint is simply added to the list of hints.
\end{zpar} \\
\begin{schema}{notifyHint}
\Delta (hint) \\
newHint? : Hint
\where
hint' = hint \cup \{newHint?\}
\end{schema} \\
play \sdef [coords : RelativeCoord, r : Rotation | \\ \t2 (coords, r) \in rules.possibleMoves] @ \\ \t1 controller.moveRequest[robot?/self, localCoords?/coords, rotation?/r] \; \; \comp \\ \t1 play
\end{class}

The Viewer has no knowledge of the Board; every change of the Board must be communicated to the Viewer via the Controller. The variable 'boardChanged' is used as a flag to indicate that the board has changed and the Viewer has not yet updated the view.
\begin{class}{Viewer}
\begin{state}
controller : Controller \\
boardChanged : \bool \\
currentSnapshot : BoardSnapshot \\
\end{state}\\
\begin{zpar}
In initialize, the Viewer attaches itself to the Controller, using the addViewer-method; the viewer parameter in addViewer is this Viewer. ???
\end{zpar} \\
\begin{schema}{Init}
boardChanged = \false
\end{schema}\\
\begin{zpar}
When the game has ended, the Viewer is notified by the Controller via notifyGameOver. The Viewer will now show an animation of fireworks and all robots that have not won the game will explode.
\end{zpar} \\
notifyGameOver \sdef \mathbb{M}.showFireworks \\
\begin{zpar}
With notifyStateChange, the Viewer is notified by the Controller that the Board has changed. The Viewer sets boardChanged to true, to indicate that it has not yet updated the view.
\end{zpar} \\
\begin{schema}{notifyStateChange}
\Delta (boardChanged)
\where
boardChanged' = \true
\end{schema}\\
\znewpage
\begin{zpar}
The updateView-method uses the value of boardChanged to update the view. If this variable is true, then the Viewer requests a new snapshot from the Board, via the Controller, and updates the view. After the update, boardChanged is set to false. If boardChanged is false, then the previous snapshot is still up-to-date and nothing is changed. Note that the variable controller in Viewer never changes here, because it is simply used to request a board snapshot.
\end{zpar} \\
updateView \sdef ([boardChanged = \false] \;\; [] \\ \t1
([boardChanged = \true] \wedge controller.requestBoardStatus \;\; \comp \\ \t2 [\Delta(currentSnapshot), board? : BoardSnapshot | \\ \t3 currentSnapshot' = board?])) \; \; \comp \\ \t1 \mathbb{M}.updateScreen
\end{class}

The controller has knowledge about the Board and the Viewer; it also maintains a list of the robots.
\begin{class}{Controller}
\begin{state}
board : Board \\
robots : \power Robot \\
viewer : Viewer
\end{state}\\
\begin{zpar}
addViewer corresponds to the public method in Controller. It takes a viewer as an input variable; this is the Viewer that wants to attach itself to the controller. If the Controller did not have a Viewer attached to it yet, then the Controller saves the Viewer and returns itself to the Viewer. The Viewer will then be able to address the controller, for board snapshot requests. If the Controller already had a Viewer attached to it, then the add-request is simply ignored.
\end{zpar} \\
\begin{zpar}
notifyAutoMovement corresponds to the public method in Controller. It takes the Robot that requested a move as input-parameter. This method is used by the Board to let the Robot know that it has been moved by a conveyor tile.
\end{zpar} \\
notifyAutoMovement \sdef robot?.notifyAutomovement \\
\znewpage
\begin{zpar}
moveRequest corresponds to the public method in Controller. It takes local coordinates, the Robot that requested the move and a rotation as input-parameters. The Controller forwards the move request of the robot, along with the specified attributes to the Board. If the Board then responds with "WIN", then the Controller must terminate all robots, notify the Viewer that the game has ended and terminate.
\end{zpar} \\
moveRequest \sdef board.moveRequest \comp ([output? \not = WIN] [] \\ \t2 ([output? = WIN] \wedge (\bigwedge_{r : robots} r.terminate) \wedge board.canReset \; \; \wedge \\ \t2 viewer.notifyGameOver)) \\
\begin{zpar}
Notify the controller of an appropriate hint.
\end{zpar} \\
notifyHint \sdef robot?.notifyHint \\
\begin{zpar}
Notify the viewer that the board has changed.
\end{zpar} \\
notifyView \sdef requestSnapshot \comp view.notifyStateChange
\znewpage
\begin{zpar}
Initialize the controller so that it can be referred to.
\end{zpar} \\
\begin{schema}{preInitialize}
\end{schema}\\
\begin{zpar}
The real initialization of the controller, giving it a board and robots.
\end{zpar} \\
\begin{schema}{postInitialize}
\Delta (board, robots) \\
board? : Board \\
robots? : \power Robot
\where
board' = board \\
robots' = robots?
\end{schema}\\
\begin{zpar}
Remove a viewer (so that eventually, a new one can be added).
\end{zpar} \\
\begin{schema}{removeViewer}
\end{schema}\\
\begin{zpar}
Function to get a snapshot of the board.
\end{zpar} \\
requestBoardStatus \sdef board.requestSnapshot
\end{class}

\end{document} 