Systeem.svg
- Waarom staan er puntjes als triggered actie bij [Controller initialized & all robots initialized]? Ze staan ook bij Controller.notifyViewer.
- Regular = NormalTile? Houdt alsjeblieft dezelfde naamconventie aan, anders veroorzaakt dat alleen maar verwarring.
- notifyView = notifyViewer (in Controller)
- Dubbele backslash bij requestTilesExchange?
- In controller bij [Robot.OnHomeTile] is de getriggerde actie al 'notifyViewer', dus 'notifyStateChange' hoeft niet nog eens als getriggerde actie erbij te staan. In de MSC End Game wordt immers alleen getermineerd, de viewer heeft van tevoren zijn view al geüpdate om de robot op de hometile te laten zien (was dat niet duidelijk uit de MSCs dan?). 

- Ik mis de volgende methodes uit het classe diagram:
  ~ canReset: wordt niet aangeroepen door Controller; nu wordt er reset() aangeroepen bij [Robot.OnHomeTile], maar dat moet natuurlijk canReset() zijn.
  ~ getHint(): deze moet in Board bij [Robot On Hint Tile] als getriggerde actie erbij, voordat Controller.notifyHint() wordt aangeroepen.
  ~ addViewer: als onderdeel van de initialisatie van de viewer dient de viewer addViewer() aan te melden bij de Controller; dit is dus een extra getriggerde actie na 'initialize' in Viewer.
  ~ postInitialize: controller reageert wel op een postInitialize, maar ik zie deze niet terug in Board. In Board moet natuurlijk een aanroep van Controller.postInitialize() plaatsvinden. 

Verder nog een aantal opmerkingen waar ikzelf over twijfelde, dus deze moeten we misschien ook met de rest overleggen, voordat je ze al dan niet verwerkt:
- Moet in Controller moveRequest SUCCESS en WIN ook niet worden beschreven?
- Kan in Robot nou oneindig lang notifyAutoMovement gedaan worden? Staat geen verdere conditie bij, dus het lijkt alsof dit nu een beetje random kan gebeuren.
- Waar ligt nu het onderscheidt in Robot tussen terminate van de winnende robot en terminate van de verliezende robot? De winnende robot heeft een conditie, maar bij de verliezende zie ik dit niet echt terug.
- Bij [canReset == false] wordt nog steeds reset() aangeroepen. Hadden we dat inderdaad zo afgesproken, of moest er eigenlijk een andere functie aangeroepen worden (die mogelijk niet in het classe diagram staat)? Leg het anders even uit in de tekst boven de MSC, dat maakt een hoop duidelijk.