In this section, the Z-specification is given. The specification is written in Object-Z, an extension of the Z language.

\subsection{Basic Axiomatic definitions}
Several attributes that are used in later definitions in our Z schemas are defined in this section. Since some returned objects in our class diagram may contain null values, these are defined as a separate set. \\
In the class diagram, several enumerators are used: Hint, BoardResponse and Rotation. Below, the Z specification of these enumerators is given.

\begin{axdef}
Rotation == \{0, 90, 180, 270\}
\end{axdef}

\begin{axdef}
BoardResponse == \{FAILED, SUCCESS, WIN\}
\end{axdef}

\begin{axdef}
Hint == \{NORTH, EAST, SOUTH, WEST, NORTH\_EAST, \\ \t1 SOUTH\_EAST, SOUTH\_WEST, NORTH\_WEST\}
\end{axdef}

\begin{zed}
[Null]
\end{zed}

\subsection{Classes}
In the class diagram, there are two types of coordinates: absolute coordinates and relative coordinates. The absolute coordinates describe the coordinates of individual tiles on the Board; these coordinates have an x- and y-value, which are both natural numbers. The relative coordinates are used by Robots to make a move request; the relative coordinates also have an x- and y-value, but these numbers are integers. Since the move requests are communicated to the Board, the Board itself will determine the absolute coordinates that belong to these relative coordinates.

\begin{class}{Coord}
\upharpoonright (x, y) \\
\begin{state}
x : \num \\
y : \num
\end{state} \\
\begin{schema}{add}
\Delta (x, y) \\
coord? : Coord
\where
x' = coord?.x + x \\
y' = coord?.y + y
\end{schema}
\end{class}

\begin{class}{AbsoluteCoord}
Coord \\
\begin{axdef}
BoardWith, BoardHeight : \nat
\end{axdef} \\
\begin{state}
\where
0 \leq x < BoardWidth \\
0 \leq y < BoardHeight
\end{state}
\end{class}

\begin{class}{RelativeCoord}
Coord \\
\end{class}

Tile class has five specializations: NormalTile, HomeTile, HintTile, ConveyerTile and BrokenRobotTile. A Tile has a type, which is either of the above specializations, and a field 'occupier', which describes the robot that currently occupies the tile. Note that a tile does not necessarily have to be occupied by a robot, so occupies can also be null. All the specializations of Tile inherit the characteristics of Tile.
\begin{class}{Tile}
\upharpoonright (occupier) \\
\begin{state}
occupier : Robot \cup Null \\
isSnapshotTile : \bool \\
\end{state} \\
\begin{schema}{Init}
occupier = Null
\end{schema} \\
\begin{classcom}
clearTile is a help-method that clears the occupies variable of a Tile.
\end{classcom} \\
\begin{schema}{clear}
\Delta (occupier) \\
\where
occupier' = Null
\end{schema} \\
\begin{classcom}
put is a help-method that takes a robot as input-variable and sets the occupies-variable of a Tile to this robot.
\end{classcom}\\
\begin{schema}{put}
\Delta (occupier) \\
input? : Robot
\where
occupier' = input?
\end{schema} \\
\begin{schema}{rotate}
\Delta()
\end{schema}
\end{class}

\begin{class}{NormalTile}
Tile
\end{class}

\begin{class}{HintTile}
Tile
\end{class}

\begin{class}{BrokenRobotTile}
Tile
\end{class}

\begin{class}{HomeTile}
Tile \\
\upharpoonright (target) \\
\begin{classcom}
A HomeTile always belongs to one specific Robot, the target robot.
\end{classcom} \\
\begin{state}
target : Robot
\end{state}
\end{class}

\begin{class}{ConveyorTile}
Tile \\
\upharpoonright (rotation) \\
\begin{classcom}
A ConveyerTile has a certain rotation, which influences the direction in which a robot is transported.
\end{classcom} \\
\begin{state}
rotation : Rotation
\end{state} \\
\begin{classcom}
Left empty on purpose.
\end{classcom} \\
\begin{schema}{rotate}
\Delta (rotation)
\end{schema}
\end{class}

The Board class maintains several invariants and has a variety of methods, since it is one of the major components of the game.

\begin{class}{Board}
\upharpoonright (canReset, initialize) \\
\begin{state}
tiles : \power (AbsoluteCoord \fun \: \downarrow \! Tile) \\
robots : \power (Robot \fun Rotation) \\
\also \also \also
controller : Controller \\
occupied : \power AbsoluteCoord \\
adjacent : \power (AbsoluteCoord \rel AbsoluteCoord) \\
conveyorUnitDest : \power (AbsoluteCoord \pinj AbsoluteCoord) \\
conveyorDest : \power (AbsoluteCoord \pinj AbsoluteCoord)
\where
\forall t : \ran tiles | \neg t.isSnaphotTile
\also \also \also \also
\forall c : occupied | tiles(c) \in BrokenRobotTile \vee
tiles(c).occupier \not = Null \\
\also \also \also \also
\forall (c, d) : conveyorUnitDest | d \not \in occupied \; \wedge tiles(c) \in ConveyorTile \; \; \wedge \\ \t1
        tiles(c).rotation = 0 \Rightarrow (c.x = d.x + 1 \wedge c.y = d.y) \; \; \wedge \\ \t1
        tiles(c).rotation = 90 \Rightarrow (c.x = d.x \wedge c.y = d.y - 1) \; \; \wedge \\ \t1
        tiles(c).rotation = 180 \Rightarrow (c.x = d.x - 1 \wedge c.y = d.y) \; \; \wedge \\ \t1
        tiles(c).rotation = 270 \Rightarrow (c.x = d.x \wedge c.y = d.y + 1) \; \; \\
\also \also \also \also
\forall (c,d) : conveyorDest | (c,d) \in conveyorUnitDest \star \; \; \wedge \\ \t1 (tiles(d) \not \in ConveyorTile \vee conveyorUnitDest(d) = d)
\also \also \also \also
\forall (c, d) : adjacent | ~ |\!c.x - d.x\!| + |\!c.y - d.y\!| = 1 \wedge d \not \in occupied
\also \also \also \also
\forall r : robots | \exists c, d : \dom tiles @  \\ \t1 tiles(c) \in HomeTile \wedge tiles(c).target = r \; \; \wedge \\ \t1
d.occupier = r \wedge (c, d) \in (adjacent \cup conveyorDest)\star
\end{state} \\
\begin{classcom}
Initialize is called from the outside world, when a new game has to be started. Note that the tiles and robots in this method are read from an input file. After the tiles and robots have been initiated, the Board pre-initializes the Controller and initializes all the robots. Finally, the Board post-initializes the Controller with the initialized Robots and the Board.
\end{classcom} \\
\begin{schema}{Init}
reset
\end{schema} \\
\begin{schema}{internalInit}
\Delta (tiles, robots, controller)
\where
tiles' \not = Null \\
robots' \not = Null \\
controller' \not = Null
\end{schema} \\
initialize \sdef internalInit \; \comp \\ \t1
[c : Controller | c = controller] @ \bigwedge_{r : dom Robots} robots.initialize \; \comp \\ \t1
[r : \power Robots | r = \dom Robots] @ controller.initialize \\
\znewpage
\begin{classcom}
CanReset is used by the Controller to let the Board know that the game has ended and that the Board can reset. The Board can reset whenever there is HomeTile on the Board that is occupied by the target robot.
\end{classcom} \\
\begin{classcom}
Uitleg waarom init leeg is.
\end{classcom} \\
canReset \sdef [\exists t : \ran tiles | t \in HomeTileTiles @ \\
\t1 t.target = t.occupier] \wedge reset \\
\begin{classcom}
When the Board resets itself, the tiles, the controller and the robots are deleted.
\end{classcom} \\
\begin{schema}{reset}
\Delta (tiles, robots. controller)
\where
tiles' = Null \\
robots' = Null \\
controller' = Null
\end{schema} \\
\begin{classcom}
A snapshot is made by copying all the tiles and adding a mapping (same as for the original board). Next, with this snapshot the view can display the board.
\end{classcom} \\
\begin{schema}{requestSnapShot}
snapshot? : BoardSnapshot
\where
\forall (c1,t1) : tiles | \exists (c2,t2) : snapshot? | c1 = c2 \: \wedge \\ \t2
t1.occupier = t2.occupier \: \wedge \\ \t2
t1 \in NormalTile \Rightarrow t2 \in NormalTile \: \wedge \\ \t2
t1 \in HintTile \Rightarrow t2 \in HintTile \: \wedge \\ \t2
t1 \in BrokenRobotTile \Rightarrow t2 \in BrokenRobotTile \: \wedge \\ \t2
t1 \in HomeTile \Rightarrow (t2 \in HomeTile \wedge t1.target = t2.target) \: \wedge \\ \t2
t1 \in ConveyorTile \Rightarrow \\ \t3 (t2 \in ConveyorTile \wedge t2.rotation = t2.rotation)
\end{schema} \\
\znewpage
\begin{classcom}
GetHint is used by the Board to generate a hint. It takes the robot that requested a move as input-parameter. It checks where the HomeTile of the robot is and according to that gives the appropiate hint.
\end{classcom} \\
\begin{axdef}
hintMapping : \power ((\{-1, 0, 1\} \cross \{-1, 0, 1\}) \pfun \power Hint)
\where
hintMapping(-1, -1) = \{NORTH\_WEST, NORTH, WEST\} \\
hintMapping(-1, 0) = \{WEST\} \\
hintMapping(-1, 1) = \{SOUTH\_WEST, SOUTH, WEST\} \\
hintMapping(0, -1) = \{NORTH\} \\
hintMapping(0, 1) = \{SOUTH\} \\
hintMapping(1, -1) = \{NORTH\_EAST, NORTH, EAST\} \\
hintMapping(1, 0) = \{EAST\} \\
hintMapping(1, 1) = \{SOUTH\_EAST, SOUTH, EAST\} \\
\end{axdef} \\
\begin{axdef}
rotate90Deg : \power (Hint \fun Hint)
\where
rotate90Deg(NORTH) = WEST \\
rotate90Deg(WEST) = SOUTH \\
rotate90Deg(SOUTH) = EAST \\
rotate90Deg(EAST) = NORTH \\
rotate90Deg(NORTH\_EAST) = NORTH\_WEST \\
rotate90Deg(NORTH\_WEST) = SOUTH\_WEST \\
rotate90Deg(SOUTH\_WEST) = SOUTH\_EAST \\
rotate90Deg(SOUTH\_EAST) = NORTH\_EAST
\end{axdef} \\
sendPossibleHint \sdef [robot? : Robot | \\ \t2 \neg \exists c : \ran tiles | c \in HintTile \wedge c.occupier = robot?] \; \; [] \\ \t1
(getHint \comp controller.notifyHint) \\
\begin{schema}{getHint}
robot? : Robot \\
output!: Hint \\
\delta x : \{-1, 0, 1\} \\
\delta y : \{-1, 0, 1\} \\
numRotations : \nat
\where
numRotations = \frac{robots(robot?)}{90} \\
\also \also \also \also \also
\exists c1,c2 : \ran tiles, h : Hint | \\ \t1 c1 \in HomeTile \wedge
 tiles(c1).target = robot? \; \; \wedge \\ \t1 tiles(c2).occupier = robot? \wedge
 \delta x = \frac{c1.x - c2.x}{|c1.x - c2.x|} \wedge \delta y = \frac{c1.y - c2.y}{|c1.y - c2.y|} \; \; \wedge \\ \t1
 h \in robot.hintMapping(\delta x, \delta y) \; \; \wedge \\ \t1
 output! = rotate90Deg^{numRatations}(h)
\end{schema} \\
\znewpage
\begin{classcom}
getValidTiles corresponds to the private method in Board. The output is a pair of two valid tiles. A tile is valid for an exchange if it is not a HomeTile or a HintTile. Off course, the invariant also holds for this function.
\end{classcom} \\
\begin{schema}{getValidTiles}
tilePair! : Tile \cross Tile
\where
\exists b : Board, (c1, t1), (c2, t2) : tiles | \\ \t1
b.robots = robots \;\; \wedge \\ \t1
 b.tiles = (tiles \setminus \{(c1, t1), (c2, t2)\}) \cup \{(c1, t2), (c2, t1)\} \\ \t1
t1 \not = t2 \; \;  \wedge \\ \t1
t1 \not \in HomeTile \wedge t1 \not \in HintTile \; \; \wedge \\ \t1
t2 \not \in HomeTile \wedge t2 \not \in HintTile \; \; \wedge \\ \t1
tilePair! = (t1, t2)
\end{schema} \\
\begin{classcom}
Method to exchange the positions of two tiles on the board. These tiles should be valid. If a robot is on one of the tiles, it moves along.
\end{classcom} \\
\begin{schema}{exchangeTiles}
\Delta(tiles, robots) \\
tilePair? : Tile \cross Tile \\
exchangedPair! : Tile \cross Tile \\
output? : \bool
\where
output? = true\\
tilePair? = exchangedPair! \\
\also \also \also
\exists c1, c2 : \dom tiles | tiles(c1) = tilePair?.0 \wedge tiles(c2) = tilePair?.1 \; \; \wedge \\ \t1
tiles' = tiles \setminus \{(c1, tilePair?.0),(c2, tilePair?.1)\} \cup \\ \t2 \{(c1, tilePair?.1),(c2, tilePair?.0)\}
\\ \t1 \forall r : \dom robots | \\ \t2 (r \not = tiles(c1).occupier \wedge r \not = tiles(c2).occupier) \Rightarrow \\ \t3 robots'(r) = robots(r)
\end{schema} \\
moveBlockedRobot \sdef [c, d : \dom tiles, r : \dom robots | \\ \t1 tiles(c) \in ConveyorTile \wedge tiles(c).occupier = r \; \; \wedge \\ \t1 conveyorDest(c) \not = c \wedge conveyorDest(c) = d] @ \\ \t2 c.clear \wedge d.put[input?/r] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/r] \\
moveBlockedRobotsRecursive \sdef (moveBlockedRobot \; \; \comp \\ \t1 moveBlockedRobotsRecursive) \; \; [] \\ \t1 [\neg \exists (c,t) : tiles | \\ \t2 t \in ConveyorTile \wedge t.occupier \not = Null \wedge conveyorDest(c) = c] \\
\znewpage
requestTilesExchange \sdef (getValidTiles \comp exchangeTiles \; \; \comp \\
\t1 [t1, t2 : Tile | t1 = exchangedPair?.0 \wedge t2 = exchangedPair?.1] @ \\ \t2 t1.rotate \wedge t2.rotate \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/t1.occupier] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/t2.occupier]) \; \; \comp \\ \t1 moveBlockedRobotRecursive \comp board.notifyView \\
\begin{classcom}
This functions deals with the moveRequest of the controller
\end{classcom} \\
moveRequest \sdef moveWalk \; \; \comp \\ \t1 ([output? = SUCCESS \vee output? = WIN] \wedge moveRotate \; \; [] \\ \t1 [output! : \bool | output? = FAILED \wedge output! = FAILED]) \\
\begin{classcom}
Used to deal with rotations a robot wants to make.
\end{classcom} \\
\begin{schema}{moveRotate}
\Delta(robots) \\
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
output! : BoardResponse
\where
\IF localCoords.x = 0 \wedge localCoords.y = 0 \; \; \wedge \\ \t1
 \exists r : robot?.rule.possibleRotations | r = rotation?\\
\THEN output! = SUCCESS \; \; \wedge \\ \t1
robots'(robot?) = (robots(robot?) + rotation?) \mod 360 \\
\ELSE output! = FAILED \wedge robots' = robots
\end{schema} \\
\begin{classcom}
Used to deal with other movements a robot wants to make.
\end{classcom} \\
\znewpage
\begin{schema}{moveWalkPre}
localCoords? : RelativeCoord \\
robot? : Robot \\
output! : BoardResponse \\
putTile! : Tile \cup Null \\
beginTile! : Tile \\
autoMovement! : \bool
\also \also \also
pathBlockedOn : \power (\seq AbsoluteCoord \fun \nat) \\
firstConveyor : \power (\seq AbsoluteCoord \fun \nat) \\
relativeToAbsolute : \power (\seq RelativeCoord \pfun \seq AbsoluteCoord) \\
validMove : \power (Tile \fun \bool) \\
path : \power \seq AbsoluteCoord \cup Null \\
\where
beginTile!.occupier = robot?
\also \also \also \also
\forall s : \power \seq pathBlockedOn | \\ \t1
 \IF \exists (n, c) : s | occupied(c) \\ \t1
 \THEN \exists (n1, c1) : s | n1 = pathBlockedOn(s) \wedge occupied(c) \; \; \wedge \\ \t6
 (\neg \exists (n2, c2) : s | occupied(c) \wedge n2 < n1) \\ \t1
 \ELSE pathBlockedOn(s) = -1
\also \also \also \also
\forall s : \power \seq AbsoluteCoord | \\ \t1
 \IF \exists (n,c) : s | c \in ConveyorTile \wedge \neg occupied(c) \\ \t1
 \THEN \exists (n1,c1) : s | n1 = firstConveyor(s) \; \; \wedge \\ \t6 c1 \in ConveyorTile \wedge \neg occupied(c1) \; \; \wedge \\ \t6
 (\neg \exists (n2,c2) : s | c2 \in ConveyorTile \; \; \wedge \\ \t9 \t1 \neg occupied(c2) \wedge c2 < c1) \\ \t1
 \ELSE firstConveyor(s) = -1
\also \also \also \also
\forall (s1, s2) : relativeToAbsolute | \forall n : \dom s1 | \\ \t1 s2(n).x = s1(n).x + beginTile!.x \; \; \wedge \\ \t1 s2(n).y = s1(n).y + beginTile!.y
\also \also \also \also
\IF (localCoords?, robots(robot?)) \in robot?.rule.possibleMoves \; \; \wedge \\ \t1 robot?.rule.possibleMoves(localCoords?, robots(robot?) \in \\ \t9 \t4 relativeToAbsolute \\
\THEN path = relativeToAbsolute( \\ \t4 robot?.rule.possibleMoves(localCoords?, robots(robot?)) \\
\ELSE path = Null
\also \also \also \also
\end{schema} \\
\znewpage
\begin{schema}{moveWalkPre}
\forall t : Tile | validMove(t) = \exists b : Board | \\ \t2
    b.robots = robots \wedge b.tiles = tiles \; \; \wedge \\ \t1 b.tiles(beginTile!).occupier = Null \wedge b.tiles(t).occupier = robot? \; \; \wedge \\ \t1 \forall t : (\ran tiles) \setminus \{beginTile!, t\} | \\ \t2 t.occupier = tiles(b.tiles^{-1}(t)).occupier \; \; \wedge \\ \t2 t \in HomeTile \Rightarrow t.target = tiles(b.tiles^{-1}(t)).target
\also \also \also \also
\IF path = Null \vee (pathBlockedOn(path) \not = -1 \; \;\wedge \\ \t1 (firstConveyor(path) = -1 \; \; \vee \\ \t2 firstConveyor(path) > pathBlockedOn(path)) \\
\THEN output! = FAILED \; \; \wedge putTile! = Null \wedge autoMovement! = \false \\
\ELSE \IF firstConveyor(path) \not = -1 \; \; \wedge \\ \t1 validMove(conveyorDest(firstConveyor(path))) \\
\THEN output! = SUCCESS \wedge autoMovement! = \true \;\; \wedge \\ \t1 putTile! = conveyorDest(firstConveyor(path) \\
\ELSE \IF validMove(path(\#path - 1)) \\
\THEN output! = SUCCESS \wedge autoMovement! = \false \; \; \wedge \\ \t1  putTile! = path(\#path - 1) \\
\ELSE output! = FAILED \wedge autoMovement! = \false \wedge putTile! = Null
\end{schema} \\
moveWalk \sdef moveWalkPre \; \; \comp \\ \t1 (([output? = FAILED] \; \; [] \\ \t2 [output? = SUCCESS \vee output? = WIN] \wedge begintTile?.clear \; \; \wedge \\ \t2 putTile?.put[input?/robot?] \wedge board.notifyView \wedge sendPossibleHint) \; \; \wedge \\ \t1 ([autoMovement? = \false] \; \; [] \\ \t2 [autoMovement? = \true] \; \; \wedge \\ \t2 controller.notifyAutomovement[r?/robot?])) \; \; \comp \\ \t1
moveBlockedRobotsRecursive
\end{class}

A BoardSnapshot is simply a copy of the current state of the board; therefore, the BoardSnapshot maintains a mapping of absolute coordinates to the tiles.
\begin{class}{BoardSnapshot}
\upharpoonright (tiles) \\
\begin{state}
tiles : \power (AbsoluteCoord \fun Tile) \\
\where
\forall t \ran tiles | t.isSnapshotTile
\end{state}
\end{class}

A Rule consists of a list of possible moves and a list of possible rotations. The possible moves are described in terms of local coordinates, since a robot does not know its exact location on the board. Since each robot has a certain rotation, possibleMoves maps relative coordinates and rotations to each possible relative coordinate that the robot can move to. The list of possible rotations is simply a list of all rotations.
\begin{class}{Rule}
\upharpoonright (possibleMoves, possibleRotations) \\
\begin{state}
possibleMoves : \power ((RelativeCoord \times Rotation) \psurj \\ \t1 \seq RelativeCoord) \\
possibleRotations : \power Rotation
\where
\forall (c, r) : \dom possibleMoves | \\ \t1 possibleMoves(c,r)(\#possibleMoves(c, r) - 1) = c
\end{state} \\
\end{class}

A Robot has knowledge of the Controller and maintains a rule-attribute, describing the ruleset of the Robot.
\begin{class}{Robot}
\upharpoonright (rules) \\
\begin{state}
rules : Rules \\
controller : Controller \\
hints : \power Hints
\end{state}\\
\begin{schema}{Init}
rules = Null \\
controller = Null \\
hints = Null
\end{schema} \\
\begin{classcom}
The initialize of the Robot uses the parameters controller and rules. The controller-parameter is the initialized Controller; the rules-parameter is the set of rules that determine the possible moves and rotations. In the initialize, all the provided input-values are saved and the list of hints is initially empty, since the Robot has not yet received any hints.
\end{classcom} \\
\begin{schema}{initialize}
\Delta (controller, rules) \\
controller? : Controller \\
rules? : Rules
\where
controller' = controller? \\
rules' = rules?
\end{schema} \\
\begin{classcom}
NotifyAutoMovement is used by the Controller to notify that the Robot was moved, because of a conveyor belt. Note that the Robot could be rotated by a conveyor belt, so the list of hints is cleared; the Robot has now no idea where its Home Tile is.
\end{classcom} \\
\begin{schema}{notifyAutoMovement}
\Delta (hint)
\where
hint' = \emptyset
\end{schema}\\
\begin{classcom}
NotifyHint is used by the Controller to pass the hint of the Board to the Robot. Since each Robot may store a list with all the hints it has received, the new hint is simply added to the list of hints.
\end{classcom} \\
\begin{schema}{notifyHint}
\Delta (hint) \\
newHint? : Hint
\where
hint' = hint \cup \{newHint?\}
\end{schema} \\
play \sdef [coords : RelativeCoord, r : Rotation | \\ \t2 (coords, r) \in rules.possibleMoves] @ \\ \t1 controller.moveRequest[robot?/self, localCoords?/coords, rotation?/r] \; \; \comp \\ \t1 play
\end{class}

The Viewer has no knowledge of the Board; every change of the Board must be communicated to the Viewer via the Controller. The variable 'boardChanged' is used as a flag to indicate that the board has changed and the Viewer has not yet updated the view.
\begin{class}{Viewer}
\begin{state}
controller : Controller \\
boardChanged : \bool \\
currentSnapshot : BoardSnapshot \\
\end{state}\\
\begin{classcom}
In initialize, the Viewer attaches itself to the Controller, using the addViewer-method; the viewer parameter in addViewer is this Viewer. ???
\end{classcom} \\
\begin{schema}{Init}
boardChanged = \false
\end{schema}\\
\begin{classcom}
When the game has ended, the Viewer is notified by the Controller via notifyGameOver. The Viewer will now show an animation of fireworks and all robots that have not won the game will explode.
\end{classcom} \\
notifyGameOver \sdef \mathbb{M}.showFireworks \\
\begin{classcom}
With notifyStateChange, the Viewer is notified by the Controller that the Board has changed. The Viewer sets boardChanged to true, to indicate that it has not yet updated the view.
\end{classcom} \\
\begin{schema}{notifyStateChange}
\Delta (boardChanged)
\where
boardChanged' = \true
\end{schema}\\
\znewpage
\begin{classcom}
The updateView-method uses the value of boardChanged to update the view. If this variable is true, then the Viewer requests a new snapshot from the Board, via the Controller, and updates the view. After the update, boardChanged is set to false. If boardChanged is false, then the previous snapshot is still up-to-date and nothing is changed. Note that the variable controller in Viewer never changes here, because it is simply used to request a board snapshot.
\end{classcom} \\
updateView \sdef ([boardChanged = \false] \;\; [] \\ \t1
([boardChanged = \true] \wedge controller.requestBoardStatus \;\; \comp \\ \t2 [\Delta(currentSnapshot), board? : BoardSnapshot | \\ \t3 currentSnapshot' = board?])) \; \; \comp \\ \t1 \mathbb{M}.updateScreen
\end{class}

The controller has knowledge about the Board and the Viewer; it also maintains a list of the robots.
\begin{class}{Controller}
\begin{state}
board : Board \\
robots : \power Robot \\
viewer : Viewer
\end{state}\\
\begin{classcom}
addViewer corresponds to the public method in Controller. It takes a viewer as an input variable; this is the Viewer that wants to attach itself to the controller. If the Controller did not have a Viewer attached to it yet, then the Controller saves the Viewer and returns itself to the Viewer. The Viewer will then be able to address the controller, for board snapshot requests. If the Controller already had a Viewer attached to it, then the add-request is simply ignored.
\end{classcom} \\
\begin{classcom}
notifyAutoMovement corresponds to the public method in Controller. It takes the Robot that requested a move as input-parameter. This method is used by the Board to let the Robot know that it has been moved by a conveyor tile.
\end{classcom} \\
notifyAutoMovement \sdef robot?.notifyAutomovement \\
\znewpage
\begin{classcom}
moveRequest corresponds to the public method in Controller. It takes local coordinates, the Robot that requested the move and a rotation as input-parameters. The Controller forwards the move request of the robot, along with the specified attributes to the Board. If the Board then responds with "WIN", then the Controller must terminate all robots, notify the Viewer that the game has ended and terminate.
\end{classcom} \\
moveRequest \sdef board.moveRequest \comp ([output? \not = WIN] [] \\ \t2 ([output? = WIN] \wedge (\bigwedge_{r : robots} r.terminate) \wedge board.canReset \; \; \wedge \\ \t2 viewer.notifyGameOver)) \\
\begin{classcom}
Notify the controller of an appropriate hint.
\end{classcom} \\
notifyHint \sdef robot?.notifyHint \\
\begin{classcom}
Notify the viewer that the board has changed.
\end{classcom} \\
notifyView \sdef view.notifyStateChange
\znewpage
\begin{classcom}
Initialize the controller so that it can be referred to.
\end{classcom} \\
\begin{schema}{Init}
\end{schema}\\
\begin{classcom}
The real initialization of the controller, giving it a board and robots.
\end{classcom} \\
\begin{schema}{postInitialize}
\Delta (board, robots) \\
board? : Board \\
robots? : \power Robot
\where
board' = board \\
robots' = robots?
\end{schema}\\
\begin{classcom}
Remove a viewer (so that eventually, a new one can be added).
\end{classcom} \\
\begin{schema}{removeViewer}
\end{schema}\\
\begin{classcom}
Function to get a snapshot of the board.
\end{classcom} \\
requestBoardStatus \sdef board.requestSnapshot
\end{class}
