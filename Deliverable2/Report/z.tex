\documentclass[12pt]{article}
\usepackage{ltcadiz}
\usepackage{listings}
\lstset{breaklines=true, numbers=left}

\title{Report on OGO 2.2 Softwarespecification\\ Assignment 1a}
\author{
        Femke Jansen and Lasse Blaauwbroek OGO 2.2 group 6 \\
                Department of Computer Science\\
        Technical University Eindhoven\\
}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
In this section, we describe the state information, using Z schemas. We first describe the building blocks of our Z specification in the section 'basic axiomatic definitions'. In the section 'classes and invariants', we describe the entities of our class diagram, along with several invariants that should always hold, according to the specification. Hereafter, in the section 'BLA' we describe the methods of our class diagram, using Z.
\end{abstract}

\section{Basic Axiomatic definitions}
Below, we define several attributes that we will use in later definitions in our Z schemas. Since some returned objects in our class diagram may contain null values, we have defined it as a seperate set. The BoardWidth and BoardHeight attributes are defined as natural numbers.

\begin{axdef}
[Null]
\end{axdef}

\begin{axdef}
BoardWith : \nat
\end{axdef}

\begin{axdef}
BoardHeight : \nat
\end{axdef}

In our class diagram, we use several enumerators: Hint, BoardResponse and Rotation. Below, we have given the Z specification of these enumerators.

\begin{axdef}
Rotation == \{0, 90, 180, 270\}
\end{axdef}

\begin{axdef}
BoardResponse == \{FAILED, SUCCESS, WIN\}
\end{axdef}

\begin{axdef}
Hint == \{NORTH, EAST, SOUTH, WEST, NORTH\_EAST, \\ \t1 EAST\_SOUTH, SOUTH\_WEST, WEST\_NORTH\}
\end{axdef}

\begin{schema}{AbsoluteCoord}
x : \nat \cup \{0\} \\
y : \nat \cup \{0\}
\where
x < BoardWidth \\
y < BoardHeight
\end{schema}

\begin{schema}{RelativeCoord}
x : \num \\
y : \num
\end{schema}

\section{Classes and invariants}
We first describe the Tile class and all its specializations: NormalTile, HomeTile, HintTile, ConveyerTile and BrokenRobotTile. A tile has a type, which is either of the above specializations, and a field 'occupier', which describes the robot that currently occupier the tile. Note that a tile does not necessarily have to be occupied by a robot, so occupier can also be null. All the specializations of Tile inherit the characteristics of Tile. The HomeTile is different from the other tiles, since it always belongs to one specific robot, the target robot. A ConveyerTile has a certain rotation, which influences the direction in which a robot is transported.

\begin{schema}{NormalTile}
Tile
\end{schema}

\begin{schema}{HintTile}
Tile
\end{schema}

\begin{schema}{BrokenRobotTile}
Tile
\end{schema}

\begin{schema}{HomeTile}
Tile \\
target : Robot
\end{schema}

\begin{schema}{ConveyorTile}
Tile \\
rotation : Rotation
\end{schema}

\begin{schema}{Tile}
type : \{NormalTile, HomeTile, ConveyorTile, \\ \t1 BrokenRobotTile, HintTile\} \\
occupier : Robot \cup Null
\end{schema}

The Board consists of a collection of tiles, which maps absolute coordinates to a specific tile. Since each robot may have a different rotation which must be maintained, the Board also has a list of robots and their current rotation. \\
According to the informal specification, the following invariant must always be maintained: "Each robot has its own home tile and must always be able to reach this home tile." The Board is the one who decides whether a certain move request of a robot is possible, hence this invariant must be maintained by the Board.

\begin{schema}{Board}
tiles : \power (AbsoluteCoord \fun Tile) \\
robots : \power (Robot \fun Rotation) \\
controller : Controller
\where
\forall r : robots | \exists c : \dom tiles @  \\ \t1 tiles(c).type = HomeTile \wedge tiles(c).target = r \wedge \\ \t1
\exists d : \dom tiles @ d.occupier = r \wedge Reachable((c, d))
\end{schema}

A BoardSnapshot is simply a copy of the current state of the board; therefore, the BoardSnapshot maintains a mapping of absolute coordinates to the tiles.

\begin{schema}{BoardSnapshot}
tiles : \power (AbsoluteCoord \fun Tile) \\
\end{schema}

A Rule consists of a list of possible moves and a list of possible rotations. The possible moves are described in terms of local coordinates, since a robot does not know its exact location on the board. Since each robot has a certain rotation, possibleMoves maps relative coordinates and rotations to each possible relative coordinate that the robot can move to. The list of possible rotations is simply a list of all rotations.

\begin{schema}{Rule}
possibleMoves : \power ((RelativeCoord \times Rotation) \psurj \\ \t1 \seq RelativeCoord) \\
possibleRotations : \power Rotation
\end{schema}

A Robot has no knowledge about its environment; it only knows which type of robot it is and this is maintained in rules.

\begin{schema}{Robot}
rules : Rules \\
controller : Controller
\end{schema}

The Viewer has no knowledge of the Board; every change of the Board must be communicated to the Viewer via the Controller.

\begin{schema}{Viewer}
controller : Controller \\
boardChanged : \bool
\end{schema}

The controller has knowledge about the Board, the Viewer and all the robots that are currently on the board.

\begin{schema}{Controller}
board : Board \\
robots : \power Robot
viewer : Viewer
\end{schema}

\begin{schema}{Occupied}
\Xi Board \\
coord? : AbsoluteCoord \\
output! : \bool
\where
\IF (tiles(coord).type = BrokenRobotTile \; \; \vee \\ \t1
tiles(coord).occupier \not = Null \\
\THEN
output! = \true \\
\ELSE
output! = \false
\end{schema}

\begin{schema}{ConveyorUnitDest}
\Xi Board \\
input? : AbsoluteCoord \\
output! : AbsoluteCoord
\where
\IF \exists d : AbsoluteCoord @ \\ \t1
    (\exists s : Occupied | s.coord? = d @ \neg s.output!) \; \; \wedge \\ \t2
        tiles(input?).type = ConveyorTile \\ \t2
        tiles(input?).rotation = 0 \Rightarrow \\ \t3 input?.x = d.x + 1 \wedge input?.y = d.y \\ \t2
        tiles(input?).rotation = 90 \Rightarrow \\ \t3 input?.x = d.x \wedge input?.y = d.y - 1 \\ \t2
        tiles(input?).rotation = 180 \Rightarrow \\ \t3 input?.x = d.x - 1 \wedge input?.y = d.y \\ \t2
        tiles(input?).rotation = 270 \Rightarrow \\ \t3 input?.x = d.x \wedge input?.y = d.y + 1 \\ \t1
    \THEN output! = d \\ \t1
    \ELSE output! = input?
\end{schema}

\begin{schema}{ConveyorDest}
\Xi Board \\
input? : AbsoluteCoord \\
output! : AbsoluteCoord
\where
\IF (\exists s : ConveyorUnitDest | s.input? = input? @ \\ \t1 s.output! = input?) \\
\THEN output! = input? \\
\ELSE \exists p : ConveyorUnitDest, s : ConveyorDest | \\ \t2 p.input? = input? \wedge s.input? = p.output! @ \\ \t3 s.output! = output!
\end{schema}

\begin{schema}{Adjacent}
\Xi Board \\
coordA? : AbsoluteCoord \\
coordB? : AbsoluteCoord \\
output! : \bool
\where
\IF \|coordA.x - coordB.x\| + \|coordA.y - coordB.y\| = 1 \\ \t1
(\exists s : Occupied | s.coord? = coordB @ s.output! = false) \\
\THEN output! = \true \\
\ELSE output! = \false
\end{schema}

\begin{schema}{Reachable}
\Xi Board \\
coordA? : AbsoluteCoord \\
coordB? : AbsoluteCoord \\
output! : \bool
\where
\IF (\exists s : Adjacent, p,h : ConveyorDest, c,d : AbsoluteCoord | \\ \t1
    p.input? = coordA \wedge p.output! = c \\ \t1
    s.coordA? = c \wedge s.coordB? = d \\ \t1
    h.input? = d \wedge h.output! = coordB) \\
\THEN output! = \true \\
\ELSE output! = \false
\end{schema}

\end{document} 