\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{ltcadiz}
\begin{document}
\title{Z schemas (methods)}
\author{J. Peters, s102231}
\maketitle


BEGIN BOARD
\begin{schema}{getHint}
\Delta Board \\
robot? : Robot \\
output!: Hint
\where
\exists t, t1: Tile | t.occupies = robot? @\\ \t1
t1.type = HomeTile @ t1.target = robot? \\ \t1
\exists coord, coord1: AbsoluteCoord | tiles(coord) = t \\ \t2
tiles(coord1) = t1 \\ \t2
\IF coord.x = coord1.x \\ \t3
coord.x < coord1.x \\ \t2
\THEN output! = EAST \\ \t2
\IF coord.x = coord1.x \\ \t3
coord.x > coord1.x \\ \t2
\THEN output! = WEST \\ \t2
\IF coord.y = coord1.y \\ \t3
coord.y < coord1.y \\ \t2
\THEN output! = SOUTH \\ \t2
\IF coord.y = coord1.y \\ \t3
coord.y > coord1.y \\ \t2
\THEN output! = NORTH \\ \t2
\IF coord.x < coord1.x \\ \t3
coord.y < coord1.y \\ \t2
\THEN \exists hint: \{SOUTH, EAST, EAST\_SOUTH\} | output! = hint \\ \t2
\IF coord.x < coord1.x \\ \t3
coord.y > coord1.y \\ \t2
\THEN \exists hint: \{NORTH, EAST, NORTH\_EAST\} | output! = hint \\ \t2
\IF coord.x > coord1.x \\ \t3
coord.y < coord1.y \\ \t2
\THEN \exists hint: \{SOUTH, WEST, SOUTH\_WEST\} | output! = hint \\ \t2
\IF coord.x > coord1.x \\ \t3
coord.y > coord1.y \\ \t2
\THEN \exists hint: \{NORTH, WEST, WEST\_NORTH\} | output! = hint
\end{schema}

Rekening houdende met de invariant...
\begin{schema}{getValidTiles}
\Xi Board \\
output! : (Tile \cross Tile)
\where
\exists t,t1: Tile | t \not = t1  @ \\ \t1
t.type \not = HomeTile \\ \t1
t.type \not = HintTile \\ \t1
t1.type \not = HomeTile \\ \t1
t1.type \not = HintTile \implies \\ \t1
output! = (t \cross t1)
\end{schema}

Tileswitch aanroep goed checken / kijken naar functieaanroep notifystatechange
\begin{schema}{requestTilesExchange}
\Delta Board \\
output! : ({Robot \union Null} \cross {Robot \union Null})
\where
\exists (tile \cross tile1) : getValidTiles | \\ \t1
\exists abCoord, abCoord1 : AbsoluteCoord | tiles(abCoord) = tile \\ \t2
tiles(abCoord1) = tile1 \implies \\ \t3
tiles(abCoord) = tile1 \\ \t3
tiles(abCoord1) = tile \\ \t3
\exists r : Robot | tile.occupies = r \implies \\ \t4
\exists n : notifyStateChange | n.input? = r \\ \t3
\exists r1 : Robot | tile1.occupies = r \implies \\ \t4
\exists n1: notifyStateChange | n1.input? = r1
\end{schema}

BEGIN OK, SAVE LOCATIONS NECESSARY
\begin{schema}{moveRequest}
\Delta Board \\
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
absoluteCoord : AbsoluteCoord \\
output! : BoardResponse
\where
\IF rotation? \not = 0 \\ \t1
localCoords.x = 0 \\ \t1
localCoords.y = 0 \\ \t1
 \exists r : robot?.rule.possibleRotations | r = rotation?\\
\THEN response! = SUCCESS \\ \t1
robots(robot?) = (robots(robot?) + rotation?) \mod 360 \\
\ELSE \\ \t1
\IF robot?.rule.possibleMoves(localCoords? \cross robots(robot?)) = possiblePath(robot?) \\ \t1
rotation? = 0 \\
\THEN \exists l : calculateNewLocation | l.localCoords? = localCoords? \\ \t1
l.robot? = robot? \\ \t1
absoluteCoord = l.output! \\ \t1
\IF absoluteCoord = null \\ \t1
\THEN output! = FAILED \\ \t1
\ELSE \\ \t2
\IF tiles(absoluteCoord).type = HomeTile \\ \t3
tiles(absoluteCoord).target = robot? \\ \t2
\THEN SAVELOCATION \\ \t3
output! = WIN \\ \t2
\ELSE SAVELOCATION \\ \t3
\IF tiles(absoluteCoord).type = ConveyorTile \\ \t3
\THEN \exists n : notifyAutomovement | n.boardResponse? = SUCCESS \\ \t4
n.robot? = robot? \\ \t3
\IF tiles(absoluteCoord).type = HintTile \\ \t3
\THEN \exists n1 : notifyHint | \\ \t4
\exists hint : getHint | hint.robot? = robot? \\ \t5
hint.output! = n1.hint? \\ \t5
n1.robot? = robot? \\ \t3
output! = SUCCESS
\end{schema}

\begin{schema}{SaveLocation}
\Xi Board \\
\Delta Tile \\
absCoords? : AbsoluteCoord \\
robot? : Robot
\where
\exists t : clearTile | t.occupies = robot?\\ \t1
\exists s : put | s.input? = robot?
\end{schema}

\begin{schema}{clearTile}
\Delta Tile \\
\where
occupies' = Null
\end{schema}

\begin{schema}{put}
\Delta Tile \\
input? : Robot
\where
occupies' = input?
\end{schema}

This one should be done. Gets the path for the move it wants to do. Gets coordinate, then for all tiles it holds that if he can't pass, a conveyor tile should be in front of the obstruction (the first conveyor). Else null
\begin{schema}{calculateNewLocation}
\Xi Board \\
localCoords? : RelativeCoord \\
robot? : Robot \\
path : seq RelativeCoord \\
absoluteCoord : AbsoluteCoord \\
output! : (AbsoluteCoord \union Null) \\
\where
path = robot?.rule.possibleMoves(localCoords? \cross robots(robot?)) \\
\exists (c, t) : tiles | t.occupies = robot? \implies \\ \t1
\IF
\forall (int, coord) : path | \\ \t2
(addAbtoRel(c, coord) = Null \vee \\ \t2
(tiles(addAbtoRel(c, coord).type = BrokenRobotTile) \vee \\ \t2
\exists r: Robot | tiles(addAbtoRel(c, coord).occupies = r )\implies \\ \t3
\exists (int1, coord1) : path | int1 < int \\ \t3
tiles(addAbtoRel(c, coord1).type = ConveyorTile \\ \t3
absoluteCoord = addAbtoRel(c, coord1) \\ \t1
\THEN absoluteCoord = firstConveyor(c, path) \\ \t2
\exists s : ConveyorDest | s.input? = absoluteCoord @ \\ \t2
output! = s.output! \\ \t1
\ELSE output! = Null
\end{schema}


seq of RelativeCoord should contain conveyorTile which is not blocked (no brokenTiles / occupied tiles on path in front of conveyorTile)
Specifies that, for a given path with conveyor tile, there exists such a conveyor tile that the int is minimal. This is the AbsoluteCoord given back by the function
\begin{schema}{firstConveyor}
\Xi Board \\
firstConveyor == (AbsoluteCoord \cross seq RelativeCoord) \rightarrow AbsoluteCoord
\where
\exists absoluteCoord : AbsoluteCoord |  \\ \t1
\exists (int, coord): seq RelativeCoord |  \\ \t2
(tiles(addAbtoRel(absoluteCoord, coord).type = conveyorTile \\ \t2
conveyorInPath(absoluteCoord, (int, coord)) = addAbtoRel(absoluteCoord, coord)) \implies \\ \t3
\forall (int1, coord1): seq RelativeCoord | \\ \t3
\IF tiles(addAbtoRel(absoluteCoord, coord1).type = conveyorTile \\ \t3
\THEN int <= int1
\end{schema}

DONE
\begin{axdef}
addAbtoRel == (AbsoluteCoord \cross RelativeCoord) \rightarrow (AbsoluteCoord \union Null)
\where
\forall (a,b) : AbsoluteCoord \cross RelativeCoord | \\ \t1
\IF (0 <= a.x + b.x < BoardWidth \\ \t2
0 <= a.x + b.x < BoardHeigth) \\ \t1
\THEN
addAbtoRel(a,b).x = a.x + b.x \\ \t2
addAbtoRel(a,b).y = a.y + b.y \\ \t1
\ELSE addAbtoRel(a,b) = Null
\end{axdef}


BEGIN CONTROLLER

meerdere viewers mogelijk?
\begin{schema}{addViewer}
\Delta Controller \\
viewer? : Viewer 
\where
viewer = viewer?
\end{schema}

Rotatie moet hier in het klasse diagram nog aan toegevoegd worden. Verder heeft deze functie weinig zin, zit al in moveRequest in Board.. ROTATION? nog te verkrijgen, misschien desbetreffende robot toevoegen of kijken of er een rotatie is waarbij het kan?
\begin{schema}{canMakeMove}
\Xi Controller \\
localCoords? : RelativeCoord \\
rotation? : Rotation \\
rule? : Rule \\
output! : \bool
\where
\IF rule?.possibleRotations = rotation? \\
\THEN output! = \true \\
\ELSE \\ \t1
\IF rule?.possibleMoves(localCoords? \cross ROTATION?) \not = Null \\ \t1
\THEN output! = \true \\ \t1
\ELSE output! = \false
\end{schema}

geeft door aan robot dat die fucked is
\begin{schema}{notifyAutoMovement}
\Xi Controller \\
boardResponse? : BoardResponse \\
robot? : Robot
\where 
robot?.notifyAutomovement
\end{schema}

Onderscheid tussen moveRequest board en controller..
\begin{schema}{moveRequest}
\Xi Controller \\
\Delta Board \\
localCoords? : RelativeCoord \\
robot? : Robot \\
rotation? : Rotation \\
ouput! : BoardResponse
\where
\exists m : Board.moveRequest | m.localCoords? = localCoords \\ \t1
m.robot? = robot? \\ \t1
m.rotation? = rotation? \\ \t1
m.output! = output!
\end{schema}

onderscheid tussen robot notifyHint en die van controller
\begin{schema}{notifyHint}
\Xi Controller \\
\Delta Robot \\ 
hint? : Hint \\
robot? : Robot
\where
\exists n : robot.notifyHint | n.hint? = hint?
\end{schema}

BEGIN ROBOT

initialize geen rules nodig?
\begin{schema}{initialize}
\Delta Robot \\
rules? : Rules
\where
rules = rules? \\
hint = Null
\end{schema}

deze functie doet wist in principe eventuele hints, robot heeft dus een hint nodig lijkt me..
\begin{schema}{notifyAutoMovement}
\Delta Robot
\where
hint = Null
\end{schema}

ook hier hint heel handig
\begin{schema}{notifyHint}
\Delta Robot \\
hint? : Hint 
\where
hint = hint?
\end{schema}

wat is het nut van deze functie? Doet intern eigenlijk niks...
\begin{schema}{terminate}
\Xi Robot
\where
\end{schema}
\end{document}